<!doctype html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>é£›è¡Œæ£‹ Aeroplane Chess</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0a0a0a;--fg:#e5e7eb;--muted:#9ca3af;--card:#0b0f14;--tile-grid:#374151;
      --red:#ff5c8a;--blue:#33ccff;--yellow:#ffd633;--green:#66ffb2;
      --red-ghost:#7f2c42;--blue-ghost:#1b4a5a;--yellow-ghost:#7a6a1a;--green-ghost:#2a5f49;
      --accent:#22d3ee;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";background:var(--bg);color:var(--fg)}
    .container{max-width:1200px;margin:0 auto;padding:16px}
    .app-bar{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:14px;border:1px solid #1f2937;background:#111827;color:#e5e7eb;cursor:pointer}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .grid{display:grid;gap:16px}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:16px;padding:16px}
    .board-area{display:grid;grid-template-columns:1fr;gap:16px}
    @media(min-width:960px){.board-area{grid-template-columns:1fr 320px}}
    .section-title{font-weight:800;margin:0 0 8px}
    .muted{color:var(--muted)}
    .list{display:flex;flex-wrap:wrap;gap:8px}
    .pill{border:1px solid #334155;border-radius:999px;padding:6px 10px}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
    .board-wrap{aspect-ratio:1/1;background:#0a0a0a;border-radius:16px;border:1px solid #1f2937;display:grid;place-items:center}
    svg.board{width:100%;height:100%;max-width:min(80vh,880px)}
    .log{height:200px;overflow:auto;border-radius:12px;background:#0b0f14;border:1px solid #1f2937;padding:8px}
    fieldset{border:1px solid #334155;border-radius:12px;padding:12px}
    legend{padding:0 8px}
    label{display:flex;align-items:center;gap:8px}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    input[type="text"], select{background:#0b1220;color:#e5e7eb;border:1px solid #334155;border-radius:10px;padding:8px}
  </style>
</head>
<body>
  <header class="container app-bar" role="banner">
    <div class="row" aria-label="brand">
      <strong>âœˆï¸ é£›è¡Œæ£‹</strong>
      <span class="muted">MVP</span>
    </div>
    <nav aria-label="global">
      <button class="btn" id="btn-lobby">è¿”å›å¤§å»³</button>
      <button class="btn" id="btn-settings" aria-haspopup="dialog" aria-controls="dialog-settings">è¨­å®š</button>
      <button class="btn" id="btn-about" aria-haspopup="dialog" aria-controls="dialog-about">èªªæ˜</button>
    </nav>
  </header>

  <main class="container" id="app" role="main">
    <!-- 1) Lobby / Setup -->
    <section id="view-lobby" class="grid" aria-labelledby="title-lobby">
      <h1 id="title-lobby" class="section-title">å¤§å»³ï¼é–‹å±€è¨­å®š</h1>
      <div class="card">
        <form id="form-setup" aria-describedby="setup-help">
          <p id="setup-help" class="muted">é¸æ“‡ç©å®¶ã€é¡è‰²ã€è¦å‰‡ã€‚æŒ‰ã€Œé–‹å§‹éŠæˆ²ã€ã€‚</p>

          <fieldset>
            <legend>ç©å®¶</legend>
            <div class="row">
              <label>äººæ•¸
                <select name="playerCount" id="playerCount" aria-label="ç©å®¶äººæ•¸">
                  <option value="2" selected>2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                </select>
              </label>
            </div>
            <div id="player-list" class="grid" style="grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px">
              <!-- Player cards generated by JS -->
            </div>
          </fieldset>

          <fieldset>
            <legend>è¦å‰‡é è¨­</legend>
            <div class="row">
              <label><input type="radio" name="preset" value="classic" checked> ç¶“å…¸</label>
              <label><input type="radio" name="preset" value="fast"> é€Ÿæˆ°</label>
              <label><input type="radio" name="preset" value="custom"> è‡ªè¨‚</label>
            </div>
            <details id="rules-advanced">
              <summary>è‡ªè¨‚è¦å‰‡ï¼ˆå±•é–‹ï¼‰</summary>
              <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;margin-top:8px">
                <fieldset>
                  <legend>èµ·é£›</legend>
                  <label><input type="radio" name="takeoff" value="six" checked> æ“² 6 æ‰èµ·é£›</label>
                  <label><input type="radio" name="takeoff" value="fiveOrSix"> æ“² 5 æˆ– 6</label>
                  <label><input type="radio" name="takeoff" value="even"> æ“²å¶æ•¸</label>
                </fieldset>
                <fieldset>
                  <legend>é€£æ“² / æ‡²ç½°</legend>
                  <label><input type="checkbox" name="extraTurnOnSix" checked> æ“² 6 å¯å†æ“²</label>
                  <label><input type="checkbox" name="tripleSixPenalty"> ä¸‰é€£ 6 æ‡²ç½°</label>
                </fieldset>
                <fieldset>
                  <legend>åƒå­ / å µè·¯</legend>
                  <label><input type="checkbox" name="captureOnLand" checked> è½é»åƒå­</label>
                  <label><input type="checkbox" name="stackEnabled" checked> è‡ªå®¶ç–Šå­</label>
                  <label><input type="checkbox" name="stackMovesTogether"> ç–Šå­åˆé«”ç§»å‹•</label>
                  <label><input type="checkbox" name="blockadePassThrough"> å…è¨±ç©¿è¶Šå µè·¯</label>
                </fieldset>
                <fieldset>
                  <legend>æ·å¾‘</legend>
                  <label><input type="checkbox" name="ownColorJumpEnabled" checked> è‡ªè‰²è·³æ ¼</label>
                  <label>è·³å¹¾æ ¼ <input type="number" min="1" max="6" name="ownColorJumpSteps" value="4"></label>
                  <label><input type="checkbox" name="dashedFlightEnabled" checked> è™›ç·šé£›è¡Œ</label>
                  <label><input type="checkbox" name="captureOnFlight" checked> é£›è¡Œè½é»åƒå­</label>
                </fieldset>
                <fieldset>
                  <legend>çµ‚é»</legend>
                  <label><input type="checkbox" name="homeLaneExactEntry" checked> å…¥å®¶è·¯è¦ç²¾æº–</label>
                  <label>
                    å®Œæˆè¦å‰‡
                    <select name="finishExact">
                      <option value="exact" selected>å‰›å¥½åˆ°é”</option>
                      <option value="noMoveIfOver">è¶…å‡ºä¸å¾—å‰é€²</option>
                      <option value="bounceBack">è¶…å‡ºæŠ˜è¿”</option>
                    </select>
                  </label>
                </fieldset>
                <fieldset>
                  <legend>å…¶ä»–</legend>
                  <label><input type="checkbox" name="startTileSafe" checked> èµ·é£›æ ¼å®‰å…¨</label>
                  <label>å‹•ç•«é€Ÿåº¦
                    <select name="animSpeed">
                      <option value="slow">æ…¢</option>
                      <option value="normal" selected>æ­£å¸¸</option>
                      <option value="fast">å¿«</option>
                    </select>
                  </label>
                  <label>å›åˆè¨ˆæ™‚ï¼ˆç§’ï¼‰<input type="number" name="turnTimerSec" min="0" value="0"></label>
                  <label><input type="checkbox" name="undoEnabled" checked> å…è¨± Undo</label>
                </fieldset>
              </div>
            </details>
          </fieldset>

          <div class="row" style="margin-top:12px">
            <button type="submit" class="btn" id="btn-start">é–‹å§‹éŠæˆ²</button>
            <button type="button" class="btn" id="btn-quick">å¿«é€Ÿé–‹å§‹ï¼ˆç¶“å…¸ï¼‰</button>
            <button type="button" class="btn" id="btn-continue" disabled>ç¹¼çºŒä¸Šå±€</button>
          </div>
        </form>
      </div>
    </section>

    <!-- 2) Game / Board View -->
    <section id="view-game" class="board-area" hidden aria-labelledby="title-game">
      <h2 id="title-game" class="sr-only">å°å±€</h2>

      <div class="card board-wrap" role="application" aria-label="æ£‹ç›¤">
        <!-- SVG Board (generated by JS) -->
        <svg class="board" viewBox="0 0 1000 1000" role="img" aria-label="Aeroplane Chess Board">
          <desc>æ£‹ç›¤æœƒç”¨ç¨‹å¼å‹•æ…‹ç”¢ç”Ÿï¼šå¤–åœˆè·¯å¾‘ã€é£›ç·šã€é¡è‰²å€åŸŸèˆ‡å®¶è·¯ã€‚</desc>
          <g id="layer-grid"></g>
          <g id="layer-tiles"></g>
          <g id="layer-specials"></g>
          <g id="layer-pieces"></g>
          <g id="layer-highlights"></g>
        </svg>
      </div>

      <aside class="card" aria-label="å›åˆæ§åˆ¶">
        <div class="row" style="justify-content:space-between">
          <strong id="turn-indicator">ç•¶å‰ï¼šâ€”</strong>
          <span id="timer" class="muted" aria-live="polite"></span>
        </div>
        <div class="row" style="margin-top:8px">
          <button class="btn" id="btn-roll" aria-live="assertive" aria-label="æ“²éª°">æ“²éª° ğŸ²</button>
          <output id="dice-output" aria-live="polite" class="pill">â€“</output>
        </div>
        <div style="margin-top:12px">
          <h3 class="section-title" style="font-size:1rem">å¯ç§»å‹•æ£‹å­</h3>
          <div id="movables" class="list" aria-live="polite"></div>
        </div>
        <div style="margin-top:12px">
          <h3 class="section-title" style="font-size:1rem">æˆ°å ±</h3>
          <div id="log" class="log" role="log" aria-live="polite"></div>
        </div>
        <div class="row" style="margin-top:12px">
          <button class="btn" id="btn-undo">Undo</button>
          <button class="btn" id="btn-restart">é‡é–‹å±€</button>
        </div>
      </aside>
    </section>
  </main>

  <!-- 3) Dialogs -->
  <dialog id="dialog-settings" aria-labelledby="dialog-settings-title">
    <form method="dialog" class="card" style="min-width:320px">
      <h3 id="dialog-settings-title" class="section-title">è¨­å®š</h3>
      <label>éµç›¤æ§åˆ¶
        <select id="keyboard-mode">
          <option value="shared" selected>å…±äº«æ¨¡å¼ï¼š1â€“4 é¸æ£‹ã€Space æ“²éª°</option>
          <option value="dual">é›™äººç†±åº§ï¼šP1=1â€“4ã€P2=7â€“0</option>
        </select>
      </label>
      <label>ä¸»é¡Œ
        <select id="theme">
          <option value="dark" selected>æ·±è‰²</option>
          <option value="light">æ·ºè‰²</option>
          <option value="high">é«˜å°æ¯”</option>
        </select>
      </label>
      <div class="row" style="margin-top:12px">
        <button class="btn" value="cancel">é—œé–‰</button>
      </div>
    </form>
  </dialog>

  <dialog id="dialog-about" aria-labelledby="dialog-about-title">
    <form method="dialog" class="card" style="min-width:320px">
      <h3 id="dialog-about-title" class="section-title">èªªæ˜</h3>
      <p class="muted">åœ¨åŒä¸€è£ç½®ä¸Šè¼ªæµæ“ä½œçš„æœ¬åœ°å¤šäººé£›è¡Œæ£‹ã€‚æ”¯æ´è¦å‰‡è‡ªè¨‚èˆ‡çºŒç›¤ã€‚</p>
      <div class="row" style="margin-top:12px">
        <button class="btn" value="cancel">çŸ¥é“äº†</button>
      </div>
    </form>
  </dialog>

  <!-- 4) Templates (for cloning) -->
  <template id="tpl-player-card">
    <div class="card" data-player-card>
      <div class="row" style="justify-content:space-between;align-items:center">
        <strong>ç©å®¶ <span data-idx></span></strong>
        <span class="pill" data-color-pill>â—</span>
      </div>
      <div class="row" style="margin-top:8px">
        <label>åç¨± <input type="text" data-name placeholder="Mandy / Brian" /></label>
        <label>é¡è‰²
          <select data-color>
            <option value="red">ç´…</option>
            <option value="blue">è—</option>
            <option value="yellow">é»ƒ</option>
            <option value="green">ç¶ </option>
          </select>
        </label>
        <label>é¡å‹
          <select data-type>
            <option value="human" selected>äººé¡</option>
            <option value="ai">AI</option>
          </select>
        </label>
      </div>
    </div>
  </template>

  <!-- 5) App Script -->
  <script>
  // ========================= Rules Engine (Part 2) =========================
  (function(){
    const BOARD = {
      boardSpecVersion: "classic-52-v1",
      track: { length: 52, orderClockwise: ["red","blue","yellow","green"], startIndex: { red:0, blue:13, yellow:26, green:39 } },
      homeLane: { length: 6, entryIndex: { red:50, blue:11, yellow:24, green:37 } },
      special: {
        safeTiles: { start:true, extra:[] },
        ownColorJump: {
          enabled:true, steps:4,
          indices:{
            red:[2,6,10,14,18,22,26,30,34,38,42,46,50],
            blue:[15,19,23,27,31,35,39,43,47,51,3,7,11],
            yellow:[28,32,36,40,44,48,0,4,8,12,16,20,24],
            green:[41,45,49,1,5,9,13,17,21,25,29,33,37]
          }
        },
        flightPaths:{ enabled:true, captureOnLanding:true, edges:{
          red:[{from:4,to:17},{from:8,to:21}],
          blue:[{from:17,to:30},{from:21,to:34}],
          yellow:[{from:30,to:43},{from:34,to:47}],
          green:[{from:43,to:4},{from:47,to:8}],
        } }
      },
      bases:{ perPlayer:1 }
    };

    const DEFAULT_RULES = {
      takeoff:"six", extraTurnOnSix:true, tripleSixPenalty:false,
      captureOnLand:true, stackEnabled:true, stackMovesTogether:false, blockadePassThrough:false,
      ownColorJump:{enabled:true,steps:4}, dashedFlight:{enabled:true,captureOnLanding:true},
      homeLaneExactEntry:true, finishExact:"exact", safeTiles:{start:true,list:[]},
    };

    const mod = (n,m)=>((n%m)+m)%m;
    const clone = (x)=> (window.structuredClone? structuredClone(x) : JSON.parse(JSON.stringify(x)));

    const Pos = {
      base:(slot=0)=>({kind:'base',slot}),
      track:(idx)=>({kind:'track',idx}),
      home:(idx)=>({kind:'home',idx}),
      finished:()=>({kind:'finished'}),
      isEqual:(a,b)=>{
        if(a.kind!==b.kind) return false;
        const key = (obj)=>{
          if(typeof obj.idx==='number') return obj.idx;
          if(typeof obj.slot==='number') return obj.slot;
          return -1;
        };
        return key(a)===key(b);
      }
    };

    function buildOccupancy(state){
      const occ={ track:Array(BOARD.track.length).fill(0).map(()=>({})), home:{} };
      for(const p of state.players){
        for(const pc of state.pieces[p.id]){
          const pos=pc.pos;
          if(pos.kind==='track') occ.track[pos.idx][p.color]=(occ.track[pos.idx][p.color]||0)+1;
          else if(pos.kind==='home'){
            if(!occ.home[p.color]) occ.home[p.color]=Array(BOARD.homeLane.length).fill(0);
            occ.home[p.color][pos.idx]+=1;
          }
        }
      }
      return occ;
    }

    function canTakeoffWith(dice,rules){
      if(rules.takeoff==='six') return dice===6;
      if(rules.takeoff==='fiveOrSix') return dice===5||dice===6;
      if(rules.takeoff==='even') return dice%2===0;
      return dice===6;
    }

    function isOwnJumpTile(color,idx){ return BOARD.special.ownColorJump.indices[color].includes(idx); }
    function flightTo(color,idx){ const e=BOARD.special.flightPaths.edges[color].find(e=>e.from===idx); return e?e.to:null; }
    function isStartTile(color,idx){ return idx===BOARD.track.startIndex[color]; }
    function isSafeTrackTile(color,idx,rules){ if(rules.safeTiles.start && isStartTile(color,idx)) return true; return (rules.safeTiles.list||[]).includes(idx); }

    function generateLegalMoves(state,rules,dice){
      const player = state.players.find(p=>p.id===state.turn);
      const occ = buildOccupancy(state);
      const myPieces = state.pieces[player.id];
      const moves=[];
      myPieces.forEach((piece,i)=>{
        const pos=piece.pos; if(pos.kind==='finished') return;
        if(pos.kind==='base'){
          if(canTakeoffWith(dice,rules)){
            const destIdx = BOARD.track.startIndex[player.color];
            const tileOcc = occ.track[destIdx];
            const enemyCount = Object.entries(tileOcc).filter(([c,n])=>c!==player.color).reduce((a,[,n])=>a+n,0);
            const allyCount = tileOcc[player.color]||0;
            if(!(allyCount>0 && !rules.stackEnabled) && !(enemyCount>=2 && !rules.blockadePassThrough)){
              const events=[]; let final=Pos.track(destIdx);
              ({final,events}=resolveSpecialsAfterLanding(player,final,rules,occ,events));
              const capture=resolveCaptureOnTrack(player,final,rules,occ);
              if(!(capture?.blocked)) moves.push({pieceIndex:i,kind:'takeoff',dice,from:pos,to:final,events,capture});
            }
          }
          return;
        }
        const sim = simulateMove(player,pos,dice,rules,occ);
        if(sim && sim.legal) moves.push({pieceIndex:i,kind:'move',dice,from:pos,to:sim.final,events:sim.events,capture:sim.capture});
      });
      return moves;
    }

    function simulateMove(player,fromPos,dice,rules,occ){
      let current=clone(fromPos); let remaining=dice; const events=[];
      const isEnemyBlockade=(idx)=>{ const tileOcc=occ.track[idx]; return Object.entries(tileOcc).filter(([c,n])=>c!==player.color).some(([,n])=>n>=2); };
      while(remaining>0){
        if(current.kind==='track'){
          const atEntry = current.idx===BOARD.homeLane.entryIndex[player.color];
          if(atEntry){ current=Pos.home(0); remaining-=1; events.push({type:'enter-home'}); continue; }
          const nextIdx = mod(current.idx+1, BOARD.track.length);
          if(!rules.blockadePassThrough && isEnemyBlockade(nextIdx)) return {legal:false,reason:'blocked-by-enemy-stack',events};
          current=Pos.track(nextIdx); remaining-=1;
        } else if(current.kind==='home'){
          const next=current.idx+1;
          if(next<BOARD.homeLane.length){ current=Pos.home(next); remaining-=1; }
          else {
            if(rules.finishExact==='exact') return {legal:false,reason:'need-exact-to-finish',events};
            if(rules.finishExact==='noMoveIfOver') return {legal:false,reason:'no-move-if-over',events};
            if(rules.finishExact==='bounceBack'){ const last=BOARD.homeLane.length-1; const over=next-last; const idx=last-(over-1); current=Pos.home(idx); remaining-=1; }
          }
        } else if(current.kind==='base' || current.kind==='finished'){
          return {legal:false,reason:'invalid-start',events};
        }
      }
      let capture=null;
      if(current.kind==='track'){
        ({final:current,events}=resolveSpecialsAfterLanding(player,current,rules,occ,events));
        capture=resolveCaptureOnTrack(player,current,rules,occ);
        if(capture?.blocked) return {legal:false,reason:'land-on-enemy-blockade',events};
      } else if(current.kind==='home'){
        if(current.idx===BOARD.homeLane.length-1){ current=Pos.finished(); events.push({type:'finish'}); }
      }
      return {legal:true,final:current,events,capture};
    }

    function resolveSpecialsAfterLanding(player,pos,rules,occ,events){
      let current=clone(pos);
      if(rules.ownColorJump.enabled && current.kind==='track' && isOwnJumpTile(player.color,current.idx)){
        const target = mod(current.idx + rules.ownColorJump.steps, BOARD.track.length);
        current = Pos.track(target); events.push({type:'jump',from:pos.idx,to:target});
      }
      if(rules.dashedFlight.enabled && current.kind==='track'){
        const to = flightTo(player.color,current.idx); if(to!=null){ current=Pos.track(to); events.push({type:'flight',from:pos.idx,to}); }
      }
      return {final:current,events};
    }

    function resolveCaptureOnTrack(player,pos,rules,occ){
      if(pos.kind!=='track' || !rules.captureOnLand) return null;
      const tileOcc=occ.track[pos.idx];
      const enemyEntries=Object.entries(tileOcc).filter(([c,n])=>c!==player.color && n>0);
      if(enemyEntries.some(([,n])=>n>=2) && !rules.blockadePassThrough) return {blocked:true};
      if(isSafeTrackTile(player.color,pos.idx,rules)) return {captured:[]};
      const captured=[]; for(const [c,n] of enemyEntries){ for(let i=0;i<n;i++) captured.push({color:c}); }
      return {captured};
    }

    window.GameRules = { BOARD, DEFAULT_RULES, generateLegalMoves, simulateMove, buildOccupancy, Pos, canTakeoffWith };

    // ------------ Dev Console Smoke Tests -------------
    (function devTests(){
      const players=[{id:'P1',name:'Mandy',color:'red'},{id:'P2',name:'Brian',color:'blue'}];
      const mkBasePieces=()=>Array.from({length:BOARD.bases.perPlayer},(_,i)=>({pos:Pos.base(i)}));
      const basePieces={P1:mkBasePieces(),P2:mkBasePieces()};
      const state={turn:'P1',players,pieces:clone(basePieces)}; const rules=DEFAULT_RULES;
      console.log('[Test] èµ·é£›(6) æ‡‰æœ‰æ­¥ï¼š', generateLegalMoves(state,rules,6));
      state.pieces.P1[0].pos = Pos.track(BOARD.track.startIndex.red);
      let occ = buildOccupancy(state); console.log('[Test] å¾èµ·é»èµ°2ï¼š', simulateMove(players[0], state.pieces.P1[0].pos, 2, rules, occ));
      // æ–°å¢ï¼šåƒå­æ¸¬è©¦
      state.pieces.P2[0].pos = Pos.track((BOARD.track.startIndex.red+2)%BOARD.track.length);
      occ = buildOccupancy(state); console.log('[Test] å¯å¦åƒå­ï¼š', generateLegalMoves(state,rules,2));
      // æ–°å¢ï¼šå…¥å®¶è·¯/å®Œæˆæ¸¬è©¦ï¼ˆæ§‹é€ æ¥è¿‘çµ‚é»ï¼‰
      state.turn='P1'; state.pieces.P1[0].pos = Pos.home(4); // homeLen=6, èµ°2æ‡‰åˆ°çµ‚é»
      occ = buildOccupancy(state); console.log('[Test] çµ‚é»ç²¾æº–ï¼š', simulateMove(players[0], state.pieces.P1[0].pos, 2, rules, occ));
    })();
  })();
  // ========================= End Rules Engine =========================
  </script>

  <script>
  // =============================== App ================================
  (function ensureUniqueIds(){
    const seen=new Set();
    document.querySelectorAll('[id]').forEach(el=>{
      if(!el.id) return;
      if(seen.has(el.id)){
        el.remove();
      }else{
        seen.add(el.id);
      }
    });
  })();
  const App = {
    state:{ view:'lobby', players:[], rules:null, pieces:{}, turn:null, dice:null, history:[], settings:{keyboardMode:'shared'}, animating:false },
    geom:{ track:[], home:{}, bases:{} },
    init(){
      if(this._initialized) return;
      this._initialized=true;
      this.cache(); this.bind(); this.renderLobbyPlayers(2);
      if(localStorage.getItem('ac_save_v1')) this.$.btnContinue.disabled=false;
    },
    cache(){
      this.$={
        viewLobby:$('#view-lobby'), viewGame:$('#view-game'), playerCount:$('#playerCount'), playerList:$('#player-list'),
        formSetup:$('#form-setup'), btnQuick:$('#btn-quick'), btnStart:$('#btn-start'), btnLobby:$('#btn-lobby'), btnRoll:$('#btn-roll'),
        diceOut:$('#dice-output'), movables:$('#movables'), log:$('#log'), turn:$('#turn-indicator'), kbMode:$('#keyboard-mode'),
        btnUndo:$('#btn-undo'), btnRestart:$('#btn-restart'), btnContinue:$('#btn-continue'), svg:document.querySelector('svg.board'),
        gGrid:$('#layer-grid'), gTiles:$('#layer-tiles'), gSpecials:$('#layer-specials'), gPieces:$('#layer-pieces'), gHL:$('#layer-highlights')
      };
      function $(sel){ return document.querySelector(sel); }
    },
    bind(){
      if(this._bound) return;
      this._bound=true;
      this.$.playerCount.addEventListener('change',e=>this.renderLobbyPlayers(parseInt(e.target.value,10)));
      this.$.formSetup.addEventListener('submit',e=>{ e.preventDefault(); this.startGame(); });
      this.$.btnQuick.addEventListener('click',()=>{ this.applyPreset('classic'); this.startGame(); });
      this.$.btnContinue.addEventListener('click',()=>this.continueFromSave());
      this.$.btnLobby.addEventListener('click',()=>this.toLobby());
      this.$.btnRoll.addEventListener('click',()=>this.rollDice());
      this.$.btnUndo.addEventListener('click',()=>this.undo());
      this.$.btnRestart.addEventListener('click',()=>{ this.clearSave(); this.toLobby(); });
      $('#btn-settings').addEventListener('click',()=>$('#dialog-settings').showModal());
      $('#btn-about').addEventListener('click',()=>$('#dialog-about').showModal());
      this.$.kbMode.addEventListener('change',e=>{ this.state.settings.keyboardMode=e.target.value; this.log(`éµç›¤æ¨¡å¼ï¼š${this.state.settings.keyboardMode}`); });
      document.addEventListener('keydown',e=>this.onKey(e));
    },
    renderLobbyPlayers(n){
      const host=this.$.playerList; host.innerHTML='';
      const colors=['red','blue','yellow','green'];
      for(let i=0;i<n;i++){
        const tpl=document.getElementById('tpl-player-card'); const node=tpl.content.cloneNode(true);
        node.querySelector('[data-idx]').textContent=i+1;
        node.querySelector('[data-name]').value = i===0?'Mandy':(i===1?'Brian':'');
        node.querySelector('[data-color]').value = colors[i%colors.length];
        node.querySelector('[data-type]').value = (i<2?'human':'ai');
        host.appendChild(node);
      }
    },
    applyPreset(name){
      if(name==='classic') this.state.rules = Object.assign({}, window.GameRules.DEFAULT_RULES);
      else if(name==='fast') this.state.rules = Object.assign({}, window.GameRules.DEFAULT_RULES,{takeoff:'fiveOrSix'});
      else this.state.rules = Object.assign({}, window.GameRules.DEFAULT_RULES);
    },
    readRulesFromForm(){
      const f=this.$.formSetup; const chk=n=>!!f.querySelector(`[name="${n}"]`)?.checked; const val=n=>f.querySelector(`[name="${n}"]:checked`)?.value; const num=(n,d)=>{const x=parseInt(f.querySelector(`[name="${n}"]`)?.value??d,10); return isNaN(x)?d:x;};
      return {
        takeoff: val('takeoff')||'six', extraTurnOnSix:chk('extraTurnOnSix'), tripleSixPenalty:chk('tripleSixPenalty'),
        captureOnLand:chk('captureOnLand'), stackEnabled:chk('stackEnabled'), stackMovesTogether:chk('stackMovesTogether'), blockadePassThrough:chk('blockadePassThrough'),
        ownColorJump:{enabled:chk('ownColorJumpEnabled'),steps:num('ownColorJumpSteps',4)}, dashedFlight:{enabled:chk('dashedFlightEnabled'),captureOnLanding:chk('captureOnFlight')},
        homeLaneExactEntry:chk('homeLaneExactEntry'), finishExact:(f.querySelector('[name="finishExact"]')?.value)||'exact',
        safeTiles:{start:chk('startTileSafe'),list:[]}
      };
    },
    normalizePieces(){
      for(const player of this.state.players){
        const pcs=Array.isArray(this.state.pieces[player.id])?this.state.pieces[player.id]:[];
        pcs.forEach((pc,idx)=>{
          if(typeof pc.baseSlot!=='number') pc.baseSlot=idx;
          if(pc.pos?.kind==='base' && typeof pc.pos.slot!=='number') pc.pos.slot=pc.baseSlot;
        });
        this.state.pieces[player.id]=pcs;
      }
    },
    startGame(){
      // players
      const cards=this.$.playerList.querySelectorAll('[data-player-card]'); const players=[]; const seen=new Set();
      cards.forEach((card,idx)=>{ const name=card.querySelector('[data-name]').value||`ç©å®¶${idx+1}`; const color=card.querySelector('[data-color]').value; const type=card.querySelector('[data-type]').value||'human'; if(seen.has(color)) return; seen.add(color); players.push({id:`P${idx+1}`,name,color,type}); });
      if(players.length<2){ this.log('è‡³å°‘éœ€è¦ 2 ä½ç©å®¶'); return; }
      this.state.players=players; this.state.turn=players[0].id; this.state.history=[]; this.state.pieces={};
      const preset=(this.$.formSetup.querySelector('input[name="preset"]:checked')?.value)||'classic';
      this.state.rules = (preset==='custom')? this.readRulesFromForm() : (preset==='fast'? Object.assign({},window.GameRules.DEFAULT_RULES,{takeoff:'fiveOrSix'}) : Object.assign({},window.GameRules.DEFAULT_RULES));
      const pieceCount=window.GameRules.BOARD.bases.perPlayer||1;
      for(const p of players){
        this.state.pieces[p.id]=Array.from({length:pieceCount},(_,idx)=>({pos:window.GameRules.Pos.base(idx), baseSlot:idx}));
      }
      this.normalizePieces();
      this.state.legalMoves=[]; this.state.animating=false;
      this.toGame(); this.bootstrapBoard(); this.redrawPieces(); this.updateTurnUI(); this.saveGame(); this.log('éŠæˆ²é–‹å§‹ï¼'); this.maybeAutoPlayIfAI();
    },
    toGame(){ this.$.viewLobby.hidden=true; this.$.viewGame.hidden=false; this.state.view='game'; },
    toLobby(){ this.$.viewLobby.hidden=false; this.$.viewGame.hidden=true; this.state.view='lobby'; },

    // --------- Board Rendering ---------
    bootstrapBoard(){
      const svg=this.$.svg; const W=1000,H=1000; svg.setAttribute('viewBox',`0 0 ${W} ${H}`); const cx=W/2,cy=H/2,r=380;
      const gGrid=this.$.gGrid,gTiles=this.$.gTiles,gSpecials=this.$.gSpecials,gPieces=this.$.gPieces,gHL=this.$.gHL; gGrid.innerHTML=gTiles.innerHTML=gSpecials.innerHTML=gPieces.innerHTML=gHL.innerHTML='';
      const NS='http://www.w3.org/2000/svg'; const css=getComputedStyle(document.documentElement); const color=(name)=>css.getPropertyValue(name).trim();
      const geom=this.geom={track:[],home:{},bases:{}};
      const el=(n,a={},ch=[])=>{ const node=document.createElementNS(NS,n); for(const [k,v] of Object.entries(a)) node.setAttribute(k,v); ch.forEach(c=>node.appendChild(c)); return node; };
      const ringPoint=(i,total=window.GameRules.BOARD.track.length)=>{ const a=(Math.PI*2)*(i/total)-Math.PI/2; const kx=Math.cos(a),ky=Math.sin(a); const rx=r*(0.85+0.15*Math.pow(Math.sin(a*2),2)); const ry=r*(0.85+0.15*Math.pow(Math.cos(a*2),2)); return [cx+kx*rx, cy+ky*ry]; };
      gGrid.appendChild(el('circle',{cx,cy,r:r+60,fill:'#0a0a0a',stroke:color('--tile-grid'),'stroke-width':2,opacity:.5}));
      const total=window.GameRules.BOARD.track.length; const startIdx=window.GameRules.BOARD.track.startIndex; const entryIdx=window.GameRules.BOARD.homeLane.entryIndex; const ownJump=window.GameRules.BOARD.special.ownColorJump.indices;
      const tint=(idx)=> ownJump.red.includes(idx)?'var(--red-ghost)': ownJump.blue.includes(idx)?'var(--blue-ghost)': ownJump.yellow.includes(idx)?'var(--yellow-ghost)': ownJump.green.includes(idx)?'var(--green-ghost)':'transparent';
      for(let i=0;i<total;i++){ const [x,y]=ringPoint(i); geom.track[i]={x,y}; const s=44; gTiles.appendChild(el('rect',{x:x-s/2,y:y-s/2,width:s,height:s,rx:10,fill:tint(i),stroke:color('--tile-grid'),'stroke-width':2})); if(Object.values(entryIdx).includes(i)) gSpecials.appendChild(el('path',{d:`M ${x-10} ${y} l 10 -8 l 0 16 Z M ${x+6} ${y} l 10 -8 l 0 16 Z`,fill:'#e5e7eb',opacity:.8})); if(Object.values(startIdx).includes(i)) gSpecials.appendChild(el('circle',{cx:x,cy:y,r:10,fill:'#e5e7eb'})); }
      const flights=window.GameRules.BOARD.special.flightPaths.edges; for(const [ck,edges] of Object.entries(flights)){ for(const e of edges){ const {x:x1,y:y1}=geom.track[e.from]; const {x:x2,y:y2}=geom.track[e.to]; const mx=(x1+x2)/2,my=(y1+y2)/2; gSpecials.appendChild(el('path',{d:`M ${x1} ${y1} Q ${mx} ${my-80} ${x2} ${y2}`,stroke:`var(--${ck})`,'stroke-width':4,fill:'none',opacity:.7})); gSpecials.appendChild(el('polygon',{points:`${x2},${y2} ${x2-6},${y2-14} ${x2+6},${y2-14}`,fill:`var(--${ck})`,opacity:.9})); } }
      const lanes=[{color:'red',angle:-90},{color:'blue',angle:0},{color:'yellow',angle:90},{color:'green',angle:180}]; const homeLen=window.GameRules.BOARD.homeLane.length;
      lanes.forEach(L=>{ const ang=L.angle*Math.PI/180,ux=Math.cos(ang),uy=Math.sin(ang),baseR=r-30,step=48; geom.home[L.color]=[]; for(let i=0;i<homeLen;i++){ const x=cx+ux*(baseR-i*step), y=cy+uy*(baseR-i*step); geom.home[L.color][i]={x,y}; const s=44; const fill=i===homeLen-1?`var(--${L.color})`:'transparent'; const stroke=i===homeLen-1?`var(--${L.color})`:color('--tile-grid'); gTiles.appendChild(el('rect',{x:x-s/2,y:y-s/2,width:s,height:s,rx:10,fill,stroke,'stroke-width':2})); }});
      gGrid.appendChild(el('rect',{x:cx-60,y:cy-60,width:120,height:120,transform:`rotate(45 ${cx} ${cy})`,fill:'#0f172a',stroke:color('--tile-grid'),'stroke-width':2}));
      const baseDefs={red:{dx:-350,dy:-350},blue:{dx:350,dy:-350},yellow:{dx:350,dy:350},green:{dx:-350,dy:350}};
      for(const [col,{dx,dy}] of Object.entries(baseDefs)){ const group=el('g',{}); const x=cx+dx,y=cy+dy,w=180,h=180; group.appendChild(el('rect',{x:x-w/2,y:y-h/2,width:w,height:h,rx:22,fill:`var(--${col})`,opacity:.08,stroke:`var(--${col})`,'stroke-width':2})); const slots=[]; for(let i=-1;i<=1;i+=2){ for(let j=-1;j<=1;j+=2){ const sx=x+i*40,sy=y+j*40; slots.push({x:sx,y:sy}); group.appendChild(el('circle',{cx:sx,cy:sy,r:22,fill:'none',stroke:`var(--${col})`,'stroke-width':2,opacity:.8})); } } geom.bases[col]=slots; gGrid.appendChild(group); }
      gGrid.appendChild(el('circle',{cx,cy,r:r+150,fill:'none',stroke:'#000','stroke-width':140,opacity:.35}));
    },

    // --------- UI helpers ---------
    log(msg){ const div=document.createElement('div'); const t=new Date().toLocaleTimeString(); div.textContent=`[${t}] ${msg}`; this.$.log.prepend(div); },
    currentPlayer(){ return this.state.players.find(p=>p.id===this.state.turn); },
    updateTurnUI(){ this.$.turn.textContent=`ç•¶å‰ï¼š${this.currentPlayer().name}`; },

    // --------- Game Flow ---------
    rollDice(){
      if(this.state.animating) return;
      const v=1+Math.floor(Math.random()*6);
      this.$.diceOut.textContent=v;
      this.state.dice=v;

      const st={turn:this.state.turn,players:this.state.players,pieces:this.state.pieces};
      const rules=this.state.rules||window.GameRules.DEFAULT_RULES;

      this.state.legalMoves=window.GameRules.generateLegalMoves(st,rules,v);
      this.highlightMovables();
      this.log(`${this.currentPlayer().name} æ“²åˆ° ${v}`);

      if((this.state.legalMoves||[]).length===0){
        const me=this.currentPlayer();
        const myPieces=this.state.pieces[me.id]||[];
        const anyAtBase=myPieces.some(pc=>pc.pos.kind==='base');
        if(anyAtBase && !window.GameRules.canTakeoffWith(v,rules)){
          this.log('ï¼ˆæç¤ºï¼‰éœ€è¦æŒ‡å®šéª°é¢å…ˆå¯ä»¥èµ·é£›');
        }else{
          this.log('ï¼ˆæç¤ºï¼‰æœ¬å›åˆæ²’æœ‰åˆæ³•æ­¥ï¼Œç›´æ¥äº¤æ£’');
        }

        const again=(v===6 && rules.extraTurnOnSix);
        if(again){
          this.log('æ“²åˆ° 6ï¼šå†æ“²ä¸€æ¬¡');
          this.state.dice=null;
          this.$.diceOut.textContent='â€“';
          this.state.legalMoves=[];
          this.highlightMovables();
          this.updateTurnUI();
          this.maybeAutoPlayIfAI();
        }else{
          this.advanceTurn();
        }
        return;
      }

      if(this.isAI(this.currentPlayer())) this.maybeAutoPlayIfAI();
    },
    highlightMovables(){
      const g=this.$.gHL; g.innerHTML='';
      const host=this.$.movables; host.innerHTML='';
      const player=this.currentPlayer(); if(!player) return;

      const moves=this.state.legalMoves||[];
      const byPiece=new Map();
      moves.forEach(m=>{
        if(!byPiece.has(m.pieceIndex)) byPiece.set(m.pieceIndex,[]);
        byPiece.get(m.pieceIndex).push(m);
      });

      const pcs=this.state.pieces[player.id]||[];
      pcs.forEach((pc,idx)=>{
        const where=this.posToXY(player.color,pc.pos,idx);
        if(!where) return;
        const hasMove=byPiece.has(idx);
        const ring=document.createElementNS('http://www.w3.org/2000/svg','circle');
        ring.setAttribute('cx',where.x);
        ring.setAttribute('cy',where.y);
        ring.setAttribute('r',hasMove?28:22);
        ring.setAttribute('fill',hasMove?'rgba(34,211,238,0.12)':'rgba(255,255,255,0.03)');
        ring.setAttribute('stroke',hasMove?'var(--accent)':'transparent');
        ring.setAttribute('stroke-width',hasMove?'2':'0');
        if(hasMove){
          ring.style.cursor='pointer';
          ring.addEventListener('click',()=>{
            const options=byPiece.get(idx)||[];
            if(options.length===1){
              this.applyMove(options[0]);
            }else if(options.length>1){
              const firstBtn=host.querySelector(`button[data-piece="${idx}"]`);
              if(firstBtn){
                firstBtn.focus();
                if(firstBtn.scrollIntoView){
                  firstBtn.scrollIntoView({block:'nearest'});
                }
              }
            }
          });
        }
        g.appendChild(ring);

        const txt=document.createElementNS('http://www.w3.org/2000/svg','text');
        txt.setAttribute('x',where.x);
        txt.setAttribute('y',where.y+4);
        txt.setAttribute('text-anchor','middle');
        txt.setAttribute('font-size','14');
        txt.setAttribute('fill','#e5e7eb');
        txt.textContent=String(idx+1);
        g.appendChild(txt);

        if(hasMove){
          const movesForPiece=byPiece.get(idx);
          movesForPiece.forEach((mv,optIdx)=>{
            const btn=document.createElement('button');
            btn.type='button';
            btn.className='btn';
            btn.dataset.piece=String(idx);
            btn.dataset.option=String(optIdx);
            const prefix=movesForPiece.length>1?`${idx+1} è™Ÿæ£‹ï¼ˆé¸é … ${optIdx+1}ï¼‰`:`${idx+1} è™Ÿæ£‹`;
            btn.textContent=`${prefix}ï¼š${this.describeMove(mv)}`;
            btn.addEventListener('click',()=>this.applyMove(mv));
            host.appendChild(btn);
          });
        }
      });

      if(host.childElementCount===0){
        const span=document.createElement('span');
        span.className='muted';
        span.textContent='æ²’æœ‰å¯ç§»å‹•æ£‹å­';
        host.appendChild(span);
      }
    },
    describeMove(move){
      const parts=[];
      if(move.kind==='takeoff') parts.push('èµ·é£›');
      else if(typeof move.dice==='number') parts.push(`å‰é€² ${move.dice}`);
      if(move.events){
        if(move.events.some(ev=>ev.type==='enter-home')) parts.push('å…¥å®¶è·¯');
        if(move.events.some(ev=>ev.type==='jump')) parts.push('è·³æ ¼');
        if(move.events.some(ev=>ev.type==='flight')) parts.push('é£›è¡Œ');
        if(move.events.some(ev=>ev.type==='finish')) parts.push('çµ‚é»');
      }
      const capturedCount=Array.isArray(move.capture?.captured)?move.capture.captured.length:0;
      if(capturedCount>0) parts.push('åƒå­');
      return parts.join(' â†’ ')||'ç§»å‹•';
    },
    posToXY(color,pos,pieceIndex=null){
      if(pos.kind==='track') return this.geom.track[pos.idx];
      if(pos.kind==='home') return this.geom.home[color][pos.idx];
      if(pos.kind==='base'){
        const slots=this.geom.bases[color]||[];
        if(slots.length===0) return null;
        const slotFromPos=(typeof pos.slot==='number')?pos.slot:null;
        const idx=(slotFromPos!=null?slotFromPos:(pieceIndex!=null?pieceIndex:0));
        return slots[idx%slots.length];
      }
      return null;
    },
    redrawPieces(){
      const g=this.$.gPieces; g.innerHTML='';
      g.onclick=(e)=>{
        if(this.state.animating) return;
        const target=e.target.closest('[data-player][data-index]');
        if(!target) return;
        const pid=target.dataset.player;
        const idx=parseInt(target.dataset.index,10);
        if(pid!==this.state.turn||Number.isNaN(idx)) return;
        const mv=(this.state.legalMoves||[]).find(m=>m.pieceIndex===idx);
        if(mv) this.applyMove(mv);
      };
      for(const p of this.state.players){
        const pcs=this.state.pieces[p.id]||[];
        pcs.forEach((pc,idx)=>{
          const xy=this.posToXY(p.color,pc.pos,idx);
          if(!xy) return;
          const c=document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('cx',xy.x);
          c.setAttribute('cy',xy.y);
          c.setAttribute('r',18);
          c.setAttribute('fill',`var(--${p.color})`);
          c.setAttribute('stroke','#0b0f14');
          c.setAttribute('stroke-width','3');
          c.dataset.player=p.id;
          c.dataset.index=idx;
          this.$.gPieces.appendChild(c);
          const t=document.createElementNS('http://www.w3.org/2000/svg','text');
          t.setAttribute('x',xy.x);
          t.setAttribute('y',xy.y+4);
          t.setAttribute('text-anchor','middle');
          t.setAttribute('font-size','12');
          t.setAttribute('fill','#0b0f14');
          t.textContent=String(idx+1);
          t.dataset.player=p.id;
          t.dataset.index=idx;
          t.style.cursor='pointer';
          this.$.gPieces.appendChild(t);
        });
      }
    },

    applyMove(move){
      this.pushHistory();
      const pid=this.state.turn;
      const player=this.currentPlayer();
      const piece=this.state.pieces[pid][move.pieceIndex];
      const fromXY=this.posToXY(player.color,piece.pos,move.pieceIndex);
      const toXY=this.posToXY(player.color,move.to,move.pieceIndex)||fromXY;
      this.state.animating=true;
      this.animatePiece(player,fromXY,toXY,520).then(async()=>{
        const capturedInfos=[];
        if(move.capture && move.capture.captured && move.to.kind==='track'){
          for(const opp of this.state.players){
            if(opp.id===pid) continue;
            const oppPieces=this.state.pieces[opp.id]||[];
            oppPieces.forEach((pc,idx)=>{
              if(pc.pos.kind==='track' && pc.pos.idx===move.to.idx){
                capturedInfos.push({opp,pieceIndex:idx});
              }
            });
          }
        }

        for(const info of capturedInfos){
          const from=this.geom.track[move.to.idx];
          const capturedPiece=this.state.pieces[info.opp.id]?.[info.pieceIndex];
          const slotIndex=typeof capturedPiece?.baseSlot==='number'?capturedPiece.baseSlot:info.pieceIndex;
          const targetBase=this.posToXY(info.opp.color, window.GameRules.Pos.base(slotIndex), slotIndex);
          if(targetBase){
            await this.animatePiece({color:info.opp.color}, from, targetBase, 420);
          }
        }

        const slotIndex=typeof piece.baseSlot==='number'?piece.baseSlot:move.pieceIndex;
        if(move.to.kind==='base'){
          piece.pos=window.GameRules.Pos.base(slotIndex);
        }else{
          piece.pos=move.to;
        }
        piece.baseSlot=slotIndex;

        if(capturedInfos.length>0){
          for(const info of capturedInfos){
            const capturedPiece=this.state.pieces[info.opp.id]?.[info.pieceIndex];
            if(!capturedPiece) continue;
            const slot=typeof capturedPiece.baseSlot==='number'?capturedPiece.baseSlot:info.pieceIndex;
            capturedPiece.baseSlot=slot;
            capturedPiece.pos=window.GameRules.Pos.base(slot);
          }
          this.log(`${player.name} åƒå­ï¼æŠŠå°æ‰‹é€å›åŸºåœ°`);
        }

        if(move.events){
          move.events.forEach(ev=>{
            if(ev.type==='enter-home') this.log(`${player.name} é€²å…¥å®¶è·¯`);
            if(ev.type==='jump') this.log(`${player.name} è§¸ç™¼è·³æ ¼ (+${this.state.rules.ownColorJump.steps})`);
            if(ev.type==='flight') this.log(`${player.name} èµ°é£›ç·š`);
            if(ev.type==='finish') this.log(`${player.name} æŠµé”çµ‚é»ï¼`);
          });
        }

        this.redrawPieces();
        this.$.gHL.innerHTML='';
        this.pulseAt(toXY.x,toXY.y,`var(--${player.color})`);
        if(move.to.kind==='track'){
          const faces=this.computeThreatFaces(move.to.idx);
          this.showThreatBadge(toXY.x,toXY.y,faces);
        }else{
          this.showThreatBadge(toXY.x,toXY.y,[]);
        }

        const again=(this.state.dice===6 && this.state.rules.extraTurnOnSix);
        this.state.animating=false;
        if(!again){
          this.advanceTurn();
        }else{
          this.updateTurnUI();
          this.maybeAutoPlayIfAI();
        }
      });
    },
    advanceTurn(){ const i=this.state.players.findIndex(p=>p.id===this.state.turn); const next=(i+1)%this.state.players.length; this.state.turn=this.state.players[next].id; this.state.dice=null; this.$.diceOut.textContent='â€“'; this.updateTurnUI(); this.saveGame(); this.maybeAutoPlayIfAI(); },
    onKey(e){
      if(this.state.view!=='game' || this.state.animating) return;
      const mode=this.state.settings.keyboardMode;
      const pIdx=this.state.players.findIndex(p=>p.id===this.state.turn);
      const pieces=this.state.pieces[this.state.turn]||[];
      const pieceCount=pieces.length;
      if(e.code==='Space'){
        e.preventDefault();
        this.rollDice();
        return;
      }
      if(e.key==='u'||e.key==='U'){
        this.undo();
        return;
      }
      let selIndex=null;
      if(mode==='shared'){
        const keys=['1','2','3','4','5','6','7','8','9'];
        const idx=keys.indexOf(e.key);
        if(idx>-1 && idx<pieceCount) selIndex=idx;
      } else if(mode==='dual'&&this.state.players.length>=2){
        if(pIdx===0){
          const keys=['1','2','3','4'];
          const idx=keys.indexOf(e.key);
          if(idx>-1 && idx<pieceCount) selIndex=idx;
        } else if(pIdx===1){
          const keys=['7','8','9','0'];
          const idx=keys.indexOf(e.key);
          if(idx>-1 && idx<pieceCount) selIndex=idx;
        }
      }
      if(selIndex!=null){
        const mv=(this.state.legalMoves||[]).find(m=>m.pieceIndex===selIndex);
        if(mv) this.applyMove(mv);
      }
    },

    // --------- Persistence / Undo ---------
    snapshot(){ return JSON.parse(JSON.stringify({players:this.state.players,pieces:this.state.pieces,turn:this.state.turn,rules:this.state.rules})); },
    saveGame(){ try{ localStorage.setItem('ac_save_v1', JSON.stringify(this.snapshot())); }catch(e){} },
    loadGame(){ try{ const s=localStorage.getItem('ac_save_v1'); return s?JSON.parse(s):null; }catch(e){ return null; } },
    clearSave(){ try{ localStorage.removeItem('ac_save_v1'); }catch(e){} },
    continueFromSave(){
      const data=this.loadGame();
      if(!data){ this.log('å†‡å„²å­˜å°å±€'); return; }
      this.state.players=data.players||[];
      this.state.pieces=data.pieces||{};
      this.state.turn=data.turn||null;
      this.state.rules=data.rules||window.GameRules.DEFAULT_RULES;
      this.state.history=[];
      this.normalizePieces();
      this.toGame();
      this.bootstrapBoard();
      this.redrawPieces();
      this.updateTurnUI();
      this.log('å·²è¼‰å…¥ä¸Šå±€');
      this.maybeAutoPlayIfAI();
    },
    pushHistory(){ const snap=this.snapshot(); this.state.history=[snap]; },
    undo(){ const snap=this.state.history?.pop?.(); if(!snap){ this.log('ç„¡å¯ Undo å˜…æ­¥'); return; } this.state.players=snap.players; this.state.pieces=snap.pieces; this.state.turn=snap.turn; this.state.rules=snap.rules; this.state.dice=null; this.normalizePieces(); this.$.diceOut.textContent='â€“'; this.redrawPieces(); this.$.gHL.innerHTML=''; this.updateTurnUI(); this.saveGame(); this.log('å·²æ’¤éŠ·ä¸€æ­¥'); },

    // --------- AI ---------
    isAI(player){ return (player.type||'human')==='ai'; },
    chooseAIMove(){
      const player=this.currentPlayer();
      const moves=this.state.legalMoves||[];
      if(moves.length===0) return null;
      const rules=this.state.rules||window.GameRules.DEFAULT_RULES;
      const distToFinish=(color,pos)=>{
        const L=window.GameRules.BOARD.track.length;
        const entry=window.GameRules.BOARD.homeLane.entryIndex[color];
        const homeLen=window.GameRules.BOARD.homeLane.length;
        if(pos.kind==='finished') return 0;
        if(pos.kind==='home') return (homeLen-1-pos.idx);
        if(pos.kind==='track'){
          const dToEntry=((entry-pos.idx)%L+L)%L;
          return dToEntry+1+(homeLen-1);
        }
        return 999;
      };
      const isSafeTile=(color,idx)=>{
        const start=window.GameRules.BOARD.track.startIndex[color];
        if(rules.safeTiles?.start && idx===start) return true;
        return (rules.safeTiles?.list||[]).includes(idx);
      };
      const captureRiskProb=(color,idx)=>{
        if(isSafeTile(color,idx)) return 0;
        let hits=0;
        const L=window.GameRules.BOARD.track.length;
        for(const opp of this.state.players){
          if(opp.id===player.id) continue;
          const oppPieces=this.state.pieces[opp.id]||[];
          for(const pc of oppPieces){
            if(pc.pos.kind!=='track') continue;
            const d=((idx-pc.pos.idx)%L+L)%L;
            if(d>=1&&d<=6) hits+=1;
          }
        }
        return Math.min(1,hits/6);
      };
      const myPieces=this.state.pieces[player.id]||[];
      const scored=moves.map(m=>{
        const beforePos=myPieces[m.pieceIndex]?.pos||window.GameRules.Pos.base();
        const before=distToFinish(player.color,beforePos);
        const after=distToFinish(player.color,m.to);
        let score=(before-after)*4;
        const cap=(m.capture&&(m.capture.captured||[]).length)||0;
        score+=cap*1000;
        if(m.to.kind==='finished') score+=900;
        if((m.events||[]).some(e=>e.type==='enter-home')) score+=400;
        if((m.events||[]).some(e=>e.type==='jump')) score+=140;
        if((m.events||[]).some(e=>e.type==='flight')) score+=90;
        if(m.kind==='takeoff') score+=80;
        if(m.to.kind==='track' && isSafeTile(player.color,m.to.idx)) score+=60;
        if(m.to.kind==='track'){
          const prob=captureRiskProb(player.color,m.to.idx);
          score-=prob*700;
        }
        return {move:m,score,before,after};
      });
      scored.sort((a,b)=> b.score!==a.score? b.score-a.score : ((a.before-a.after)!==(b.before-b.after)? (b.before-b.after)-(a.before-a.after) : (((b.move.capture?.captured||[]).length)-((a.move.capture?.captured||[]).length))));
      return scored[0].move;
    },
    maybeAutoPlayIfAI(){
      const player=this.currentPlayer();
      if(!this.isAI(player)) return;
      setTimeout(()=>{
        if(this.state.animating) return this.maybeAutoPlayIfAI();
        const current=this.currentPlayer();
        if(!this.isAI(current)) return;
        if(current.id!==player.id){
          this.maybeAutoPlayIfAI();
          return;
        }
        if(this.state.dice==null){
          this.rollDice();
          return;
        }
        const mv=this.chooseAIMove();
        if(mv){
          this.applyMove(mv);
        }else{
          this.log(`${current.name} ç„¡æ­¥å¯èµ°`);
          this.advanceTurn();
        }
      },300);
    },

    // --------- Anim / Effects ---------
    animatePiece(player,from,to,duration=480){ return new Promise(resolve=>{ const g=this.$.gHL; const NS='http://www.w3.org/2000/svg'; const ghost=document.createElementNS(NS,'circle'); ghost.setAttribute('cx',from.x); ghost.setAttribute('cy',from.y); ghost.setAttribute('r',18); ghost.setAttribute('fill',`var(--${player.color})`); ghost.setAttribute('stroke','#0b0f14'); ghost.setAttribute('stroke-width','3'); g.appendChild(ghost); const t0=performance.now(); const ease=t=>1-Math.pow(1-t,3); const step=(now)=>{ const p=Math.min(1,(now-t0)/duration), e=ease(p); const x=from.x+(to.x-from.x)*e, y=from.y+(to.y-from.y)*e; ghost.setAttribute('cx',x); ghost.setAttribute('cy',y); if(p<1) requestAnimationFrame(step); else { g.removeChild(ghost); resolve(); } }; requestAnimationFrame(step); }); },
    pulseAt(x,y,color){ const g=this.$.gHL; const NS='http://www.w3.org/2000/svg'; const ring=document.createElementNS(NS,'circle'); ring.setAttribute('cx',x); ring.setAttribute('cy',y); ring.setAttribute('r','8'); ring.setAttribute('fill','none'); ring.setAttribute('stroke',color); ring.setAttribute('stroke-width','3'); ring.setAttribute('opacity','0.9'); g.appendChild(ring); let r=8; const id=setInterval(()=>{ r+=4; ring.setAttribute('r',r); const op=parseFloat(ring.getAttribute('opacity')); ring.setAttribute('opacity',String(Math.max(0,op-0.12))); if(r>36){ clearInterval(id); g.removeChild(ring);} },16); },
    computeThreatFaces(targetIdx){ const L=window.GameRules.BOARD.track.length; const me=this.currentPlayer(); const faces=new Set(); for(const opp of this.state.players){ if(opp.id===me.id) continue; const oppPieces=this.state.pieces[opp.id]||[]; for(const pc of oppPieces){ if(pc.pos.kind!=='track') continue; const d=((targetIdx-pc.pos.idx)%L+L)%L; if(d>=1&&d<=6) faces.add(d); } } return Array.from(faces).sort((a,b)=>a-b); },
    showThreatBadge(x,y,faces){ const g=this.$.gHL; g.querySelectorAll('.threat-badge').forEach(n=>n.remove()); if(!faces||faces.length===0) return; const NS='http://www.w3.org/2000/svg'; const bx=x+26,by=y-26; const badge=document.createElementNS(NS,'g'); badge.setAttribute('class','threat-badge'); const rect=document.createElementNS(NS,'rect'); rect.setAttribute('x',bx-12); rect.setAttribute('y',by-10); rect.setAttribute('width',24); rect.setAttribute('height',20); rect.setAttribute('rx',6); rect.setAttribute('fill','#ef4444'); rect.setAttribute('stroke','#000'); rect.setAttribute('stroke-width','2'); const txt=document.createElementNS(NS,'text'); txt.setAttribute('x',bx); txt.setAttribute('y',by+5); txt.setAttribute('text-anchor','middle'); txt.setAttribute('font-size','12'); txt.setAttribute('fill','#0b0f14'); txt.textContent=String(faces[0]); badge.appendChild(rect); badge.appendChild(txt); g.appendChild(badge); }
  };
  window.App = App; window.addEventListener('DOMContentLoaded',()=>App.init());
  // ============================= End App ===============================
  </script>
</body>
</html>
