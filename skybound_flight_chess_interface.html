<!doctype html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Skybound Flight Chess Interface</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0a0a0a;--fg:#e5e7eb;--muted:#9ca3af;--card:#0b0f14;--tile-grid:#374151;
      --red:#ff5c8a;--blue:#33ccff;--yellow:#ffd633;--green:#66ffb2;
      --red-ghost:#7f2c42;--blue-ghost:#1b4a5a;--yellow-ghost:#7a6a1a;--green-ghost:#2a5f49;
      --accent:#22d3ee;
    }
    body[data-theme="light"]{
      --bg:#f8fafc;--fg:#0f172a;--muted:#475569;--card:#ffffff;--tile-grid:#cbd5f5;
      --red:#e11d48;--blue:#0ea5e9;--yellow:#f59e0b;--green:#10b981;
      --red-ghost:rgba(225,29,72,0.12);--blue-ghost:rgba(14,165,233,0.12);--yellow-ghost:rgba(245,158,11,0.15);--green-ghost:rgba(16,185,129,0.12);
      --accent:#0891b2;
    }
    body[data-theme="high"]{
      --bg:#020617;--fg:#f8fafc;--muted:#f1f5f9;--card:#030712;--tile-grid:#f8fafc;
      --red:#ff4d6d;--blue:#38bdf8;--yellow:#facc15;--green:#4ade80;
      --red-ghost:rgba(255,77,109,0.28);--blue-ghost:rgba(56,189,248,0.26);--yellow-ghost:rgba(250,204,21,0.32);--green-ghost:rgba(74,222,128,0.3);
      --accent:#fbbf24;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";background:var(--bg);color:var(--fg);transition:background .18s ease,color .18s ease}
    .container{max-width:1200px;margin:0 auto;padding:16px}
    .app-bar{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:14px;border:1px solid #1f2937;background:#111827;color:#e5e7eb;cursor:pointer}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .grid{display:grid;gap:16px}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:16px;padding:16px}
    .board-area{display:grid;grid-template-columns:1fr;gap:16px}
    @media(min-width:960px){.board-area{grid-template-columns:1fr 320px}}
    .section-title{font-weight:800;margin:0 0 8px}
    .muted{color:var(--muted)}
    .list{display:flex;flex-direction:column;gap:8px;align-items:stretch}
    #movables .btn{width:100%;justify-content:flex-start;text-align:left;padding:8px 12px;font-size:.85rem;line-height:1.3;white-space:normal}
    .pill{border:1px solid #334155;border-radius:999px;padding:6px 10px}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
    .board-wrap{position:relative;aspect-ratio:1/1;background:#0a0a0a;border-radius:16px;border:1px solid #1f2937;display:grid;place-items:center;overflow:hidden}
    #board-overlay{position:absolute;inset:0;padding:24px;display:flex;align-items:center;justify-content:center;text-align:center;font-weight:600;color:rgba(226,232,240,0.92);background:rgba(15,23,42,0.72);backdrop-filter:blur(2px);border-radius:inherit;opacity:0;pointer-events:none;transition:opacity .22s ease}
    body[data-view="lobby"] #board-overlay{opacity:1}
    svg.board{width:100%;height:100%;max-width:min(75vh,820px)}
    @media(max-width:959px){
      svg.board{max-width:min(92vw,640px)}
    }
    .tile-icon{stroke-width:2;vector-effect:non-scaling-stroke}
    .plane-token{stroke:#0b0f14;stroke-width:2.4;stroke-linejoin:round;stroke-linecap:round;vector-effect:non-scaling-stroke;cursor:pointer;transition:transform .18s ease,filter .18s ease;fill:currentColor;}
    .plane-red{color:var(--red)}
    .plane-blue{color:var(--blue)}
    .plane-yellow{color:var(--yellow)}
    .plane-green{color:var(--green)}
    .plane-token.selected{filter:url(#glow);}
    g[data-finished="true"] .plane-token{opacity:.9;}
    g[data-disabled="true"] .plane-token{opacity:.4;}
    g[data-disabled="true"] text{opacity:.4;}
    .finish-badge circle{fill:rgba(15,23,42,.82);stroke:rgba(255,255,255,.82);stroke-width:2}
    .runway-tile{fill:rgba(255,255,255,.08);stroke-width:2}
    .runway-red{stroke:var(--red)}
    .runway-blue{stroke:var(--blue)}
    .runway-yellow{stroke:var(--yellow)}
    .runway-green{stroke:var(--green)}
    .tile-ring{fill:none;stroke-dasharray:4 4}
    .log{height:200px;overflow:auto;border-radius:12px;background:#0b0f14;border:1px solid #1f2937;padding:8px}
    fieldset{border:1px solid #334155;border-radius:12px;padding:12px}
    legend{padding:0 8px}
    label{display:flex;align-items:center;gap:8px}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    input[type="text"], select{background:#0b1220;color:#e5e7eb;border:1px solid #334155;border-radius:10px;padding:8px}
    body[data-theme="light"] input[type="text"], body[data-theme="light"] select{background:#e2e8f0;color:#0f172a;border-color:#cbd5f5}
    body[data-theme="high"] input[type="text"], body[data-theme="high"] select{background:#0f172a;color:#f8fafc;border-color:#38bdf8}
    #turn-banner{position:sticky;top:16px;z-index:20;display:block;padding:10px 18px;border-radius:999px;background:rgba(34,211,238,0.16);color:#0f172a;font-weight:600;border:1px solid rgba(34,211,238,0.35);box-shadow:0 8px 18px rgba(15,23,42,0.35);max-width:fit-content;margin:0 auto 12px auto;opacity:0;transform:translateY(-6px);transition:opacity .18s ease,transform .22s ease}
    #turn-banner[data-show="true"]{opacity:1;transform:translateY(0)}
    #hint-card{margin-top:12px;padding:12px;border-radius:14px;background:rgba(15,23,42,0.68);border:1px solid #1f2937;display:flex;flex-direction:column;gap:8px}
    #hint-card h3{margin:0;font-size:.95rem;font-weight:600;color:#f1f5f9}
    #hint-card ul{margin:0;padding-left:18px;display:flex;flex-direction:column;gap:4px;color:#cbd5f5;font-size:.9rem}
    #hint-card .hint-meta{font-size:.8rem;color:var(--muted)}
    #toast-host{pointer-events:none;min-height:26px}
    #last-move-card{margin-top:12px;padding:12px;border-radius:14px;background:rgba(34,211,238,0.12);border:1px solid rgba(34,211,238,0.35);display:flex;flex-direction:column;gap:8px;transition:background .18s ease,border-color .18s ease,color .18s ease}
    #last-move-card[data-empty="true"]{background:rgba(15,23,42,0.4);border-color:rgba(148,163,184,0.35)}
    #last-move-card[data-has-summary="true"]{background:var(--last-move-accent-soft,rgba(34,211,238,0.16));border-color:var(--last-move-accent,rgba(34,211,238,0.35))}
    #last-move-card h3{margin:0;font-size:1rem}
    #last-move-card p{margin:0;line-height:1.4}
    #last-move-card .last-move-meta{font-size:.82rem;color:var(--muted)}
    #last-move-card[data-has-summary="true"] .last-move-meta{color:rgba(226,232,240,0.9)}
    body[data-theme="light"] #last-move-card[data-has-summary="true"] .last-move-meta{color:#334155}
    #last-move-card .btn{align-self:flex-start;padding:8px 12px;font-size:.85rem}
    #last-move-captured{display:flex;flex-wrap:wrap;gap:6px;margin:0;padding:0;list-style:none}
    #last-move-captured li{padding:4px 8px;border-radius:999px;font-size:.78rem;background:rgba(15,23,42,0.25);color:var(--fg)}
    body[data-theme="light"] #last-move-card[data-empty="true"]{background:rgba(148,163,184,0.15);border-color:rgba(148,163,184,0.35)}
    body[data-theme="light"] #last-move-card[data-has-summary="true"]{background:var(--last-move-accent-soft,rgba(8,145,178,0.14));border-color:var(--last-move-accent,rgba(8,145,178,0.35))}
    body[data-theme="light"] #last-move-captured li{background:rgba(15,23,42,0.08);color:#0f172a}
    body[data-theme="high"] #last-move-card[data-empty="true"]{background:rgba(15,23,42,0.6);border-color:rgba(248,250,252,0.55)}
    body[data-theme="high"] #last-move-card[data-has-summary="true"]{background:var(--last-move-accent-soft,rgba(251,191,36,0.28));border-color:var(--last-move-accent,#fbbf24)}
    body[data-theme="high"] #last-move-captured li{background:rgba(248,250,252,0.18);color:#f8fafc}
    .toast-message{display:inline-flex;align-items:center;gap:6px;padding:6px 12px;margin-top:6px;border-radius:999px;background:rgba(34,211,238,0.18);color:#38bdf8;border:1px solid rgba(56,189,248,0.4);box-shadow:0 4px 14px rgba(8,47,73,0.3);opacity:0;transform:translateY(-4px);transition:opacity .18s ease,transform .22s ease}
    .toast-message[data-show="true"]{opacity:1;transform:translateY(0)}
    body[data-view="lobby"] #view-game aside{opacity:.4;pointer-events:none}
    #specials-legend{border:1px solid #1f2937;border-radius:12px;padding:12px;background:rgba(15,23,42,0.6)}
    #specials-legend ul{margin:8px 0 0 0;padding-left:0;display:flex;flex-direction:column;gap:4px;font-size:.85rem;color:#e2e8f0;list-style:none}
    #specials-legend li{display:flex;align-items:center;gap:6px}
    #specials-legend .legend-icon{display:inline-flex;width:1.4rem;align-items:center;justify-content:center;margin-right:4px}
    #specials-legend .status-line{font-size:.85rem;margin:0;color:#a1a9ba}
    #specials-legend[data-disabled="true"]{opacity:.5}
    #specials-legend[data-disabled="true"] [data-specials-status]{color:#f87171}
    #specials-legend[data-disabled="false"] [data-specials-status]{color:#34d399}
    body[data-view="game"] #view-game aside{opacity:1;pointer-events:auto}
    @media(prefers-reduced-motion:reduce){
      #turn-banner{transition:opacity .1s ease;transform:none}
      .toast-message{transition:opacity .1s ease;transform:none}
    }
  </style>
</head>
<body>
  <header class="container app-bar" role="banner">
    <div class="row" aria-label="brand">
      <strong>✈️ 飛行棋</strong>
      <span class="muted">MVP</span>
    </div>
    <nav aria-label="global">
      <button class="btn" id="btn-lobby">返回大廳</button>
      <button class="btn" id="btn-settings" aria-haspopup="dialog" aria-controls="dialog-settings">設定</button>
      <button class="btn" id="btn-about" aria-haspopup="dialog" aria-controls="dialog-about">說明</button>
    </nav>
  </header>

  <main class="container" id="app" role="main">
    <div id="turn-banner" role="status" aria-live="assertive" hidden></div>
    <!-- 1) Lobby / Setup -->
    <section id="view-lobby" class="grid" aria-labelledby="title-lobby">
      <h1 id="title-lobby" class="section-title">大廳／開局設定</h1>
      <div class="card">
        <form id="form-setup" aria-describedby="setup-help">
          <p id="setup-help" class="muted">選擇玩家、顏色、規則。按「開始遊戲」。</p>

          <fieldset>
            <legend>玩家</legend>
            <div class="row">
              <label>人數
                <select name="playerCount" id="playerCount" aria-label="玩家人數">
                  <option value="2" selected>2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                </select>
              </label>
            </div>
            <div id="player-list" class="grid" style="grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px">
              <!-- Player cards generated by JS -->
            </div>
          </fieldset>

          <fieldset>
            <legend>規則預設</legend>
            <div class="row">
              <label><input type="radio" name="preset" value="classic" checked> 經典</label>
              <label><input type="radio" name="preset" value="fast"> 速戰</label>
              <label><input type="radio" name="preset" value="custom"> 自訂</label>
            </div>
            <details id="rules-advanced">
              <summary>自訂規則（展開）</summary>
              <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;margin-top:8px">
                <fieldset>
                  <legend>起飛</legend>
                  <label><input type="radio" name="takeoff" value="six"> 擲 6 才起飛</label>
                  <label><input type="radio" name="takeoff" value="fiveOrSix"> 擲 5 或 6</label>
                  <label><input type="radio" name="takeoff" value="even" checked> 擲偶數</label>
                </fieldset>
                <fieldset>
                  <legend>連擲 / 懲罰</legend>
                  <label><input type="checkbox" name="extraTurnOnSix" checked> 擲 6 可再擲</label>
                  <label><input type="checkbox" name="tripleSixPenalty"> 三連 6 懲罰</label>
                </fieldset>
                <fieldset>
                  <legend>吃子 / 堵路</legend>
                  <label><input type="checkbox" name="captureOnLand" checked> 落點吃子</label>
                  <label><input type="checkbox" name="stackEnabled" checked> 自家疊子</label>
                  <label><input type="checkbox" name="stackMovesTogether"> 疊子合體移動</label>
                  <label><input type="checkbox" name="blockadePassThrough"> 允許穿越堵路</label>
                </fieldset>
                <fieldset>
                  <legend>捷徑</legend>
                  <label><input type="checkbox" name="ownColorJumpEnabled" checked> 自色跳格</label>
                  <label>跳幾格 <input type="number" min="1" max="6" name="ownColorJumpSteps" value="4"></label>
                  <label><input type="checkbox" name="dashedFlightEnabled" checked> 虛線飛行</label>
                  <label><input type="checkbox" name="captureOnFlight" checked> 飛行落點吃子</label>
                </fieldset>
                <fieldset>
                  <legend>特殊格</legend>
                  <label><input type="checkbox" name="specialsEnabled" checked> 啟用傳送門／增益／陷阱</label>
                  <p class="muted" style="margin:4px 0 0">順序：跳格 → 飛行 → 傳送門 → 增益 → 陷阱</p>
                </fieldset>
                <fieldset>
                  <legend>終點</legend>
                  <label><input type="checkbox" name="homeLaneExactEntry" checked> 入家路要精準</label>
                  <label>
                    完成規則
                    <select name="finishExact">
                      <option value="exact" selected>剛好到達</option>
                      <option value="noMoveIfOver">超出不得前進</option>
                      <option value="bounceBack">超出折返</option>
                    </select>
                  </label>
                </fieldset>
                <fieldset>
                  <legend>其他</legend>
                  <label><input type="checkbox" name="startTileSafe" checked> 起飛格安全</label>
                  <label>動畫速度
                    <select name="animSpeed">
                      <option value="slow">慢</option>
                      <option value="normal" selected>正常</option>
                      <option value="fast">快</option>
                    </select>
                  </label>
                  <label>回合計時（秒）<input type="number" name="turnTimerSec" min="0" value="0"></label>
                  <label><input type="checkbox" name="undoEnabled" checked> 允許 Undo</label>
                </fieldset>
              </div>
            </details>
          </fieldset>

          <div class="row" style="margin-top:12px">
            <button type="submit" class="btn" id="btn-start">開始遊戲</button>
            <button type="button" class="btn" id="btn-quick">快速開始（經典）</button>
            <button type="button" class="btn" id="btn-continue" disabled>繼續上局</button>
          </div>
        </form>
      </div>
    </section>

    <!-- 2) Game / Board View -->
    <section id="view-game" class="board-area" aria-labelledby="title-game">
      <h2 id="title-game" class="sr-only">對局</h2>

      <div class="card board-wrap" role="application" aria-label="棋盤">
        <!-- SVG Board (generated by JS) -->
        <svg class="board" viewBox="0 0 1000 1000" role="img" aria-label="Aeroplane Chess Board">
          <desc>棋盤會用程式動態產生：外圈路徑、飛線、顏色區域與家路。</desc>
          <g id="layer-background"></g>
          <g id="layer-grid"></g>
          <g id="layer-tiles"></g>
          <g id="layer-specials"></g>
          <g id="layer-hud"></g>
          <g id="layer-pieces"></g>
          <g id="layer-highlights"></g>
        </svg>
        <div id="board-overlay" aria-hidden="true"></div>
      </div>

      <aside class="card" aria-label="回合控制">
        <div class="row" style="justify-content:space-between">
          <strong id="turn-indicator">當前：—</strong>
          <span id="timer" class="muted" aria-live="polite"></span>
        </div>
        <div class="row" style="margin-top:8px">
          <button class="btn" id="btn-roll" aria-label="擲骰" aria-keyshortcuts="Space">擲骰 🎲</button>
          <output id="dice-output" aria-live="polite" class="pill" role="status">–</output>
        </div>
        <div id="toast-host" aria-live="polite"></div>
        <div id="hint-card" aria-live="polite"></div>
        <section id="last-move-card" aria-live="polite" data-empty="true">
          <h3 class="section-title" style="font-size:1rem">上一步動作</h3>
          <p id="last-move-summary" class="muted">尚未有移動記錄。</p>
          <p id="last-move-meta" class="last-move-meta"></p>
          <ul id="last-move-captured"></ul>
          <button class="btn" type="button" id="btn-replay-last" disabled>重播上一步</button>
        </section>
        <div style="margin-top:12px">
          <h3 class="section-title" style="font-size:1rem">可移動棋子</h3>
          <div id="movables" class="list" aria-live="polite"></div>
        </div>
        <div style="margin-top:12px">
          <h3 class="section-title" style="font-size:1rem">戰報</h3>
          <div id="log" class="log" role="log" aria-live="polite"></div>
        </div>
        <div class="row" style="margin-top:12px">
          <button class="btn" id="btn-undo">Undo</button>
          <button class="btn" id="btn-restart">重開局</button>
        </div>
        <section id="specials-legend" aria-label="特殊格圖例" style="margin-top:12px">
          <h3 class="section-title" style="font-size:1rem">特殊格圖例</h3>
          <p class="muted status-line">特殊格目前：<span data-specials-status>啟用</span></p>
          <ul>
            <li><span class="legend-icon">🌀</span>傳送門：瞬移至配對點（每次落地最多 1 次）</li>
            <li><span class="legend-icon">🎲</span>增壓：獲得額外擲骰或增益移動</li>
            <li><span class="legend-icon">⚠️</span>亂流：下回合停飛一輪</li>
          </ul>
          <p class="muted" style="margin-top:6px">結算順序：<span id="specials-order"></span></p>
        </section>
      </aside>
    </section>
  </main>

  <!-- 3) Dialogs -->
  <dialog id="dialog-settings" aria-labelledby="dialog-settings-title">
    <form method="dialog" class="card" style="min-width:320px">
      <h3 id="dialog-settings-title" class="section-title">設定</h3>
      <label>鍵盤控制
        <select id="keyboard-mode">
          <option value="shared" selected>共享模式：1–4 選棋、Space 擲骰</option>
          <option value="dual">雙人熱座：P1=1–4、P2=7–0</option>
          <option value="custom">自訂：依玩家卡片設定</option>
        </select>
      </label>
      <label>主題
        <select id="theme">
          <option value="dark" selected>深色</option>
          <option value="light">淺色</option>
          <option value="high">高對比</option>
        </select>
      </label>
      <div class="row" style="margin-top:12px">
        <button class="btn" value="cancel">關閉</button>
      </div>
    </form>
  </dialog>

  <dialog id="dialog-about" aria-labelledby="dialog-about-title">
    <form method="dialog" class="card" style="min-width:320px">
      <h3 id="dialog-about-title" class="section-title">說明</h3>
      <p class="muted">在同一裝置上輪流操作的本地多人飛行棋。支援規則自訂與續盤。</p>
      <div class="row" style="margin-top:12px">
        <button class="btn" value="cancel">知道了</button>
      </div>
    </form>
  </dialog>

  <!-- 4) Templates (for cloning) -->
  <template id="tpl-player-card">
    <div class="card" data-player-card>
      <div class="row" style="justify-content:space-between;align-items:center">
        <strong>玩家 <span data-idx></span></strong>
        <span class="pill" data-color-pill>●</span>
      </div>
      <div class="row" style="margin-top:8px">
        <label>名稱 <input type="text" data-name placeholder="Mandy / Brian" /></label>
        <label>顏色
          <select data-color>
            <option value="red">紅</option>
            <option value="blue">藍</option>
            <option value="yellow">黃</option>
            <option value="green">綠</option>
          </select>
        </label>
        <label>類型
          <select data-type>
            <option value="human" selected>人類</option>
            <option value="ai">AI</option>
          </select>
        </label>
        <label>控制
          <select data-control>
            <option value="auto" selected>自動（依模式）</option>
            <option value="keyboard">鍵盤</option>
            <option value="mouse">滑鼠</option>
          </select>
        </label>
      </div>
    </div>
  </template>

  <!-- 5) App Script -->
  <script>
  // =========================== Rules Engine ============================
  (function(){
      const BOARD = {
        boardSpecVersion: "skybound-variant-v2",
      track: { length: 52, orderClockwise: ["red","blue","yellow","green"], startIndex: { red:0, blue:13, yellow:26, green:39 } },
      homeLane: { length: 6, entryIndex: { red:50, blue:11, yellow:24, green:37 } },
      special: {
        safeTiles: {
          start:true,
          extra:[3,9,16,22,29,35,42,48]
        },
        powerTiles:[
          {idx:5,effect:'extra-roll',label:'🎲'},
          {idx:18,effect:'advance-2',label:'+2'},
          {idx:31,effect:'command-other',label:'⇄'},
          {idx:44,effect:'advance-2',label:'+2'}
        ],
        trapTiles:[
          {idx:12,effect:'skip-turn',label:'⚠'},
          {idx:38,effect:'skip-turn',label:'⚠'}
        ],
        portals:[
          {label:'A',from:7,to:28},
          {label:'A',from:28,to:7},
          {label:'B',from:21,to:46},
          {label:'B',from:46,to:21}
        ],
        ownColorJump: {
          enabled:true, steps:4,
          indices:{
            red:[2,6,10,14,18,22,26,30,34,38,42,46,50],
            blue:[15,19,23,27,31,35,39,43,47,51,3,7,11],
            yellow:[28,32,36,40,44,48,0,4,8,12,16,20,24],
            green:[41,45,49,1,5,9,13,17,21,25,29,33,37]
          }
        },
        flightPaths:{ enabled:true, captureOnLanding:true, edges:{
          red:[{from:4,to:17},{from:8,to:21}],
          blue:[{from:17,to:30},{from:21,to:34}],
          yellow:[{from:30,to:43},{from:34,to:47}],
          green:[{from:43,to:4},{from:47,to:8}],
        } }
      },
      bases:{ perPlayer:4 }
    };

    function validateBoard(BOARD){
      const safe = new Set(BOARD.special?.safeTiles?.extra||[]);
      const map = new Map();
      const reg = (idx,type)=>{
        if(typeof idx!=='number') return;
        map.set(idx,(map.get(idx)||[]).concat(type));
      };
      (BOARD.special?.powerTiles||[]).forEach(p=>reg(p.idx,'power'));
      (BOARD.special?.trapTiles||[]).forEach(t=>reg(t.idx,'trap'));
      (BOARD.special?.portals||[]).forEach(p=>reg(p.from,'portal'));
      const conflicts=[...map.entries()].filter(([idx,types])=>types.length>1 || safe.has(idx));
      if(conflicts.length) console.warn('Conflicting specials:', conflicts);
    }

    validateBoard(BOARD);

    const SPECIAL_BY_IDX = (()=>{
      const registry={};
      const assign=(idx,data)=>{
        if(typeof idx!=='number') return;
        registry[idx]=Object.freeze(data);
      };
      (BOARD.special?.powerTiles||[]).forEach(p=>{
        assign(p.idx,{type:'power',idx:p.idx,effect:p.effect,label:p.label});
      });
      (BOARD.special?.trapTiles||[]).forEach(t=>{
        assign(t.idx,{type:'trap',idx:t.idx,effect:t.effect,label:t.label});
      });
      (BOARD.special?.portals||[]).forEach(p=>{
        assign(p.from,{type:'portal',from:p.from,to:p.to,label:p.label});
      });
      return Object.freeze(registry);
    })();

    const DEFAULT_RULES = {
      takeoff:"even", extraTurnOnSix:true, tripleSixPenalty:false,
      captureOnLand:true, stackEnabled:true, stackMovesTogether:false, blockadePassThrough:false,
      ownColorJump:{enabled:true,steps:4}, dashedFlight:{enabled:true,captureOnLanding:true},
      homeLaneExactEntry:true, finishExact:"exact", safeTiles:{start:true,list:[3,9,16,22,29,35,42,48]},
      specials:{enabled:true,portalLimit:1},
      turnTimerSec:0, animSpeed:'normal', undoEnabled:true,
    };

    const mod = (n,m)=>((n%m)+m)%m;
    const clone = (x)=> (window.structuredClone? structuredClone(x) : JSON.parse(JSON.stringify(x)));
    const SPECIAL_RESOLUTION_ORDER = Object.freeze(['own-color-jump','flight','portal','power-up','trap']);

    const Pos = {
      base:(slot=0)=>({kind:'base',slot}),
      track:(idx)=>({kind:'track',idx}),
      home:(idx)=>({kind:'home',idx}),
      finished:()=>({kind:'finished'}),
      isEqual:(a,b)=>{
        if(a.kind!==b.kind) return false;
        const key = (obj)=>{
          if(typeof obj.idx==='number') return obj.idx;
          if(typeof obj.slot==='number') return obj.slot;
          return -1;
        };
        return key(a)===key(b);
      }
    };

    function buildOccupancy(state){
      const occ={ track:Array(BOARD.track.length).fill(0).map(()=>({})), home:{} };
      for(const p of state.players){
        for(const pc of state.pieces[p.id]){
          const pos=pc.pos;
          if(pos.kind==='track') occ.track[pos.idx][p.color]=(occ.track[pos.idx][p.color]||0)+1;
          else if(pos.kind==='home'){
            if(!occ.home[p.color]) occ.home[p.color]=Array(BOARD.homeLane.length).fill(0);
            occ.home[p.color][pos.idx]+=1;
          }
        }
      }
      return occ;
    }

    function canTakeoffWith(dice,rules){
      if(rules.takeoff==='six') return dice===6;
      if(rules.takeoff==='fiveOrSix') return dice===5||dice===6;
      if(rules.takeoff==='even') return dice%2===0;
      return dice===6;
    }

    function isOwnJumpTile(color,idx){ return BOARD.special.ownColorJump.indices[color].includes(idx); }
    function flightTo(color,idx){ const e=BOARD.special.flightPaths.edges[color].find(e=>e.from===idx); return e?e.to:null; }
    function isStartTile(color,idx){ return idx===BOARD.track.startIndex[color]; }
    function isAnyStartTile(idx){ return Object.values(BOARD.track.startIndex).includes(idx); }
    function isSafeTrackTile(color,idx,rules){
      if(rules.safeTiles.start && isAnyStartTile(idx)) return true;
      return (rules.safeTiles.list||[]).includes(idx);
    }

    function generateLegalMoves(state,rules,dice){
      const player = state.players.find(p=>p.id===state.turn);
      if(!player) return [];
      const occ = buildOccupancy(state);
      const myPieces = state.pieces[player.id]||[];
      const moves=[];
      const stackInfo=new Map();
      if(rules.stackMovesTogether && rules.stackEnabled!==false){
        const byIdx=new Map();
        myPieces.forEach((piece,idx)=>{
          if(piece.pos?.kind==='track'){
            if(!byIdx.has(piece.pos.idx)) byIdx.set(piece.pos.idx,[]);
            byIdx.get(piece.pos.idx).push(idx);
          }
        });
        byIdx.forEach((indices,idx)=>{
          indices.sort((a,b)=>a-b);
          stackInfo.set(idx,{indices,leader:indices[0]});
        });
      }
      myPieces.forEach((piece,i)=>{
        const pos=piece.pos; if(!pos || pos.kind==='finished') return;
        let stackGroup=null;
        if(rules.stackMovesTogether && rules.stackEnabled!==false && pos.kind==='track'){
          const info=stackInfo.get(pos.idx);
          if(info && info.indices.length>1){
            if(i!==info.leader) return;
            stackGroup=info.indices.slice();
          }
        }
        if(pos.kind==='base'){
          if(canTakeoffWith(dice,rules)){
            const destIdx = BOARD.track.startIndex[player.color];
            const tileOcc = occ.track[destIdx];
            const enemyCount = Object.entries(tileOcc).filter(([c,n])=>c!==player.color).reduce((a,[,n])=>a+n,0);
            const allyCount = tileOcc[player.color]||0;
            if(!(allyCount>0 && !rules.stackEnabled) && !(enemyCount>=2 && !rules.blockadePassThrough)){
              const events=[]; let final=Pos.track(destIdx);
              const pathRecord=[clone(final)];
              const special=resolveSpecialsAfterLanding(player,final,rules,occ,events,{recordPath:true,pathRecord});
              final=special.final; const eventLog=special.events; const effectsLog=special.effects||[];
              const capture=resolveCaptureOnTrack(player,final,rules,occ,{viaFlight:special.viaFlight});
              const path=(special.path&&special.path.length?special.path:pathRecord);
              let blockedByAlly=false;
              if(final.kind==='track' && rules.stackEnabled===false){
                const occDest=occ.track[final.idx]||{};
                if((occDest[player.color]||0)>0) blockedByAlly=true;
              }
              if(!(capture?.blocked) && !blockedByAlly) moves.push({pieceIndex:i,kind:'takeoff',dice,from:pos,to:final,events:eventLog,effects:effectsLog,capture,stack:[i],path});
            }
          }
          return;
        }
        const sim = simulateMove(player,pos,dice,rules,occ,{recordPath:true});
        if(sim && sim.legal){
          const allowStack=rules.stackEnabled!==false;
          const group=(allowStack && stackGroup)?stackGroup.slice():[i];
          if(sim.final && sim.final.kind==='track' && rules.stackEnabled===false){
            const occDest=occ.track[sim.final.idx]||{};
            let allyCount=occDest[player.color]||0;
            const movingCount=group.reduce((sum,idx2)=>{
              const mover=myPieces[idx2];
              if(mover?.pos?.kind==='track' && mover.pos.idx===sim.final.idx) return sum+1;
              return sum;
            },0);
            allyCount=Math.max(0,allyCount-movingCount);
            if(allyCount>0) return;
          }
          moves.push({pieceIndex:i,kind:'move',dice,from:pos,to:sim.final,events:sim.events,effects:sim.effects||[],capture:sim.capture,stack:group,path:sim.path||[]});
        }
      });
      return moves;
    }

    function simulateMove(player,fromPos,dice,rules,occ,options={}){
      let current=clone(fromPos); let remaining=dice; let events=[];
      const entryIdx=BOARD.homeLane.entryIndex[player.color];
      const isEnemyBlockade=(idx)=>{ const tileOcc=occ.track[idx]; return Object.entries(tileOcc).filter(([c,n])=>c!==player.color).some(([,n])=>n>=2); };
      let stepsTaken=0;
      const recordPath=options.recordPath===true;
      const pathRecord=recordPath?[]:null;
      const recordPosition=(pos)=>{
        if(!recordPath || !pathRecord) return;
        pathRecord.push(clone(pos));
      };
      while(remaining>0){
        if(current.kind==='track'){
          if(current.idx===entryIdx){
            if(stepsTaken===0 || !rules.homeLaneExactEntry){
              if(remaining<=0) break;
              current=Pos.home(0); remaining-=1; stepsTaken+=1; events.push({type:'enter-home'}); continue;
            }
          }
          const nextIdx = mod(current.idx+1, BOARD.track.length);
          if(!rules.blockadePassThrough && isEnemyBlockade(nextIdx)) return {legal:false,reason:'blocked-by-enemy-stack',events};
          current=Pos.track(nextIdx); remaining-=1; stepsTaken+=1; recordPosition(current);
          if(current.idx===entryIdx){
            const allowEntry = !rules.homeLaneExactEntry || remaining===0;
            if(allowEntry){
              current=Pos.home(0); recordPosition(current);
              events.push({type:'enter-home'});
              if(remaining>0){
                remaining-=1;
                stepsTaken+=1;
              }
            }
          }
        } else if(current.kind==='home'){
          const laneLength=BOARD.homeLane.length;
          const next=current.idx+1;
          if(next<laneLength){
            current=Pos.home(next);
            remaining-=1;
            stepsTaken+=1;
            recordPosition(current);
          } else {
            if(rules.finishExact==='exact') return {legal:false,reason:'need-exact-to-finish',events};
            if(rules.finishExact==='noMoveIfOver') return {legal:false,reason:'no-move-if-over',events};
            if(rules.finishExact==='bounceBack'){
              const last=laneLength-1;
              let overshoot=remaining;
              let idx=current.idx;
              let direction=-1;
              while(overshoot>0){
                let nextIdx=idx+direction;
                if(nextIdx<0){ direction=1; nextIdx=idx+direction; }
                if(nextIdx>last){ direction=-1; nextIdx=idx+direction; }
                idx=nextIdx;
                current=Pos.home(idx);
                recordPosition(current);
                stepsTaken+=1;
                overshoot-=1;
              }
              remaining=0;
            }
          }
        } else if(current.kind==='base' || current.kind==='finished'){
          return {legal:false,reason:'invalid-start',events};
        }
      }
      let capture=null;
      let specialEffects=[];
      if(current.kind==='track'){
        const special=resolveSpecialsAfterLanding(player,current,rules,occ,events,{recordPath,pathRecord});
        current=special.final; events=special.events; specialEffects=special.effects||[];
        capture=resolveCaptureOnTrack(player,current,rules,occ,{viaFlight:special.viaFlight});
        if(capture?.blocked) return {legal:false,reason:'land-on-enemy-blockade',events};
      } else if(current.kind==='home'){
        if(current.idx===BOARD.homeLane.length-1){ current=Pos.finished(); events.push({type:'finish'}); if(recordPath && pathRecord) pathRecord.push(clone(current)); }
      }
      return {legal:true,final:current,events,capture,effects:specialEffects,path:recordPath?pathRecord:undefined};
    }

    function resolveSpecialsAfterLanding(player,pos,rules,occ,events,options={}){
      // The order of resolution is fixed (see SPECIAL_RESOLUTION_ORDER):
      // own-colour jump → flight → limited portal hops → power-ups → traps.
      let current=clone(pos);
      let viaFlight=false;
      const effects=[];
      const recordPath=options.recordPath===true;
      const pathRecord=recordPath?(options.pathRecord||[]):null;
      const recordPosition=(p)=>{ if(!recordPath || !pathRecord) return; pathRecord.push(clone(p)); };
      if(rules.ownColorJump.enabled && current.kind==='track' && isOwnJumpTile(player.color,current.idx)){
        const target = mod(current.idx + rules.ownColorJump.steps, BOARD.track.length);
        current = Pos.track(target); events.push({type:'jump',from:pos.idx,to:target}); recordPosition(current);
      }
      const flightsEnabled = (BOARD.special.flightPaths?.enabled!==false);
      const flightRule = rules.dashedFlight||{};
      if(flightsEnabled && flightRule.enabled && current.kind==='track'){
        const to = flightTo(player.color,current.idx);
        if(to!=null){ current=Pos.track(to); events.push({type:'flight',from:pos.idx,to}); viaFlight=true; recordPosition(current); }
      }
      const specialsConfig = rules.specials||{};
      const specialsActive = specialsConfig.enabled!==false;
      const portalLimit = Math.max(0, specialsConfig.portalLimit ?? 1);
      const portalLookup=window.GameRules?.SPECIAL_BY_IDX||{};
      const visitedPortals=new Set();
      let portalCount=0;
      while(specialsActive && current.kind==='track'){
        const portal = portalLookup[current.idx];
        if(!portal || portal.type!=='portal' || visitedPortals.has(current.idx) || portalCount>=portalLimit) break;
        visitedPortals.add(current.idx);
        portalCount+=1;
        current=Pos.track(portal.to); recordPosition(current);
        events.push({type:'portal',label:portal.label,from:portal.from,to:portal.to});
      }
      if(specialsActive && current.kind==='track'){
        const entry = portalLookup[current.idx];
        if(entry && entry.type==='power'){
          const detail={type:'power-up',effect:entry.effect,label:entry.label,idx:entry.idx};
          events.push(detail); effects.push(detail);
        } else if(entry && entry.type==='trap'){
          const detail={type:'trap',effect:entry.effect,label:entry.label,idx:entry.idx};
          events.push(detail); effects.push(detail);
        }
      }
      return {final:current,events,viaFlight,effects,path:pathRecord};
    }

    function resolveCaptureOnTrack(player,pos,rules,occ,context={}){
      if(pos.kind!=='track' || !rules.captureOnLand) return null;
      const boardAllowsFlightCapture = BOARD.special.flightPaths.captureOnLanding!==false;
      const flightRule = rules.dashedFlight||{};
      if(context?.viaFlight && (!boardAllowsFlightCapture || flightRule.captureOnLanding===false)) return null;
      const tileOcc=occ.track[pos.idx];
      const enemyEntries=Object.entries(tileOcc).filter(([c,n])=>c!==player.color && n>0);
      if(enemyEntries.some(([,n])=>n>=2) && !rules.blockadePassThrough) return {blocked:true};
      if(isSafeTrackTile(player.color,pos.idx,rules)) return {captured:[]};
      const captured=[]; for(const [c,n] of enemyEntries){ for(let i=0;i<n;i++) captured.push({color:c}); }
      return {captured};
    }

    window.GameRules = { BOARD, DEFAULT_RULES, generateLegalMoves, simulateMove, buildOccupancy, Pos, canTakeoffWith, SPECIAL_RESOLUTION_ORDER, SPECIAL_BY_IDX };

    // (Tests removed in production build)
  })();
  // ========================= End Rules Engine =========================
  </script>

  <script>
  // =============================== App ================================
  const SVG_NS='http://www.w3.org/2000/svg';
  const SAVE_KEY='ac_save_v1';
  const SAVE_VERSION='skybound-variant-v2';
  const $ = (selector)=>document.querySelector(selector);
  const App = {
    state:{ view:'lobby', players:[], rules:null, pieces:{}, turn:null, dice:null, history:[], settings:{keyboardMode:'shared',theme:'dark'}, animating:false, consecutiveSixes:{}, turnTimerId:null, turnTimerRemaining:0, controlById:{}, inputLockUntil:0, bonusSelecting:false, pendingBonus:null, skipTurns:{}, lastMoveSummary:null, finishOrder:[], winner:null, disabledColors:{}, finishedSlots:{} },
    geom:{ track:[], home:{}, bases:{}, runway:{}, finishedSlots:{} },
    init(){
      if(this._initialized) return;
      this._initialized=true;
      this.cache(); this.bind();
      if(this.$.kbMode) this.$.kbMode.value=this.state.settings.keyboardMode||'shared';
      this.applyTheme();
      this.renderLastMove();
      this._hudLayers={static:null,dynamic:null};
      this.state.rules=this.cloneDefaultRules();
      this.applyBoardDefaultsToRules();
      this.renderLobbyPlayers(2);
      this.bootstrapBoard();
      this.redrawPieces();
      this.updateViewVisibility();
      this.updateBoardOverlay();
      this.updateSpecialsLegend();
      if(this.hasSavedGame()) this.$.btnContinue.disabled=false;
      window.addEventListener('resize',()=>this.onResize());
    },
    cache(){
      this.$={
        viewLobby:$('#view-lobby'), viewGame:$('#view-game'), playerCount:$('#playerCount'), playerList:$('#player-list'),
        formSetup:$('#form-setup'), btnQuick:$('#btn-quick'), btnStart:$('#btn-start'), btnLobby:$('#btn-lobby'), btnRoll:$('#btn-roll'),
        diceOut:$('#dice-output'), movables:$('#movables'), log:$('#log'), turn:$('#turn-indicator'), kbMode:$('#keyboard-mode'), timer:$('#timer'), hintCard:$('#hint-card'), turnBanner:$('#turn-banner'), toast:$('#toast-host'),
        btnUndo:$('#btn-undo'), btnRestart:$('#btn-restart'), btnContinue:$('#btn-continue'), svg:document.querySelector('svg.board'),
        gBack:$('#layer-background'), gGrid:$('#layer-grid'), gTiles:$('#layer-tiles'), gSpecials:$('#layer-specials'), gHud:$('#layer-hud'), gPieces:$('#layer-pieces'), gHL:$('#layer-highlights'),
        boardOverlay:$('#board-overlay'), specialsLegend:$('#specials-legend'), specialsStatus:document.querySelector('[data-specials-status]'), specialsOrder:$('#specials-order'),
        theme:$('#theme'), rulesAdvanced:$('#rules-advanced'), lastMoveCard:$('#last-move-card'), lastMoveSummary:$('#last-move-summary'), lastMoveMeta:$('#last-move-meta'), lastMoveCaptured:$('#last-move-captured'), btnReplayLast:$('#btn-replay-last')
      };
    },
    hasSavedGame(){
      try{ return !!localStorage.getItem(SAVE_KEY); }catch(e){ return false; }
    },
    bind(){
      if(this._bound) return;
      this._bound=true;
      this.$.playerCount.addEventListener('change',e=>this.renderLobbyPlayers(parseInt(e.target.value,10)));
      this.$.formSetup.addEventListener('submit',e=>{ e.preventDefault(); this.startGame(); });
      this.$.formSetup.addEventListener('change',e=>{
        if(this.$.rulesAdvanced && this.$.rulesAdvanced.contains(e.target)){
          const custom=this.$.formSetup.querySelector('input[name="preset"][value="custom"]');
          if(custom) custom.checked=true;
        }
      });
      this.$.btnQuick.addEventListener('click',()=>{ this.applyPreset('classic'); this.startGame(); });
      this.$.btnContinue.addEventListener('click',()=>this.continueFromSave());
      this.$.btnLobby.addEventListener('click',()=>this.toLobby());
      if(this.$.btnReplayLast){
        this.$.btnReplayLast.addEventListener('click',()=>this.previewLastMove());
      }
      if(this.$.theme){
        this.$.theme.addEventListener('change',e=>{
          const value=e.target.value||'dark';
          this.state.settings.theme=value;
          this.applyTheme();
          this.log(`主題已切換為：${value==='light'?'淺色':value==='high'?'高對比':'深色'}`);
        });
      }
      this.$.btnRoll.addEventListener('click',event=>{
        const isKeyboardActivation = (event instanceof MouseEvent && event.detail===0) || event?.detail===0;
        if(isKeyboardActivation){
          this.rollDice('keyboard');
          return;
        }
        const hasPointerEvents = typeof PointerEvent!=='undefined';
        if(hasPointerEvents && event instanceof PointerEvent){
          const pointerType = event.pointerType;
          if(pointerType==='mouse' || pointerType==='pen'){
            this.rollDice('mouse');
            return;
          }
        }
        this.rollDice('mouse');
      });
      this.$.btnUndo.addEventListener('click',()=>this.undo());
      this.$.btnRestart.addEventListener('click',()=>this.restartGame());
      if(this.$.playerList){
        this.$.playerList.addEventListener('change',evt=>{
          const target=evt.target;
          if(!target || typeof target.matches!=='function') return;
          if(target.matches('[data-color]')){
            const card=target.closest('[data-player-card]');
            this.syncPlayerCardColor(card);
          }
          this.updateBoardOverlay();
        });
      }
      $('#btn-settings').addEventListener('click',()=>$('#dialog-settings').showModal());
      $('#btn-about').addEventListener('click',()=>$('#dialog-about').showModal());
      this.$.kbMode.addEventListener('change',e=>{ this.state.settings.keyboardMode=e.target.value; this.log(`鍵盤模式：${this.state.settings.keyboardMode}`); this.updateControlAssignments(); this.renderHints(); this.updateTurnPrompt(true); });
      if(!this._handleKeyDown){
        this._handleKeyDown=e=>this.onKey(e);
        window.addEventListener('keydown',this._handleKeyDown,true);
      }
    },
    updateViewVisibility(){
      const view=this.state.view||'lobby';
      document.body.dataset.view=view;
      if(this.$?.viewLobby) this.$.viewLobby.hidden = (view!=='lobby');
      if(this.$?.viewGame) this.$.viewGame.hidden = false;
    },
    updateBoardOverlay(){
      const overlay=this.$?.boardOverlay; if(!overlay) return;
      const view=this.state.view||'lobby';
      if(view==='game'){ overlay.textContent=''; return; }
      if(this.hasSavedGame()){
        overlay.textContent='🗺️ 棋盤預覽 — 有儲存對局，可按「繼續上局」或重新開局';
        return;
      }
      const cardNodes=this.$?.playerList?.querySelectorAll('[data-player-card]')||[];
      const cards=Array.from(cardNodes);
      const seenColors=new Set();
      let hasDuplicate=false;
      cards.forEach(card=>{
        const colorSelect=card.querySelector('[data-color]');
        const color=(colorSelect?.value||'').trim();
        if(!color) return;
        if(seenColors.has(color)){
          hasDuplicate=true;
        }
        seenColors.add(color);
      });
      if(seenColors.size===0 && cards.length===0 && Array.isArray(this.state.players)){
        this.state.players.forEach(player=>{
          if(!player?.color) return;
          if(seenColors.has(player.color)){
            hasDuplicate=true;
          }
          seenColors.add(player.color);
        });
      }
      if(hasDuplicate){
        overlay.textContent='⚠️ 棋盤預覽 — 玩家顏色不可重複，請調整後再開始';
        return;
      }
      const uniqueCount=seenColors.size;
      if(uniqueCount>=2){
        overlay.textContent=`🗺️ 棋盤預覽 — ${uniqueCount} 位玩家準備就緒，按「開始遊戲」起飛`;
      }else{
        overlay.textContent='🗺️ 棋盤預覽 — 需至少 2 位玩家開始';
      }
    },
    syncPlayerCardColor(card){
      if(!card) return;
      const colorSelect=card.querySelector('[data-color]');
      const pill=card.querySelector('[data-color-pill]');
      if(!colorSelect) return;
      const value=colorSelect.value||'';
      card.dataset.color=value;
      if(pill){
        const label=(colorSelect.options && colorSelect.selectedIndex>=0)?(colorSelect.options[colorSelect.selectedIndex]?.textContent||''):'●';
        const trimmed=(label||'').trim();
        const displayLabel=trimmed.length?trimmed:'●';
        pill.textContent=displayLabel;
        pill.setAttribute('aria-label',`顏色：${trimmed.length?trimmed:'未設定'}`);
        if(value){
          pill.style.background=`var(--${value})`;
          pill.style.color='#0b0f14';
          pill.style.borderColor=`var(--${value})`;
        }else{
          pill.style.background='';
          pill.style.color='';
          pill.style.borderColor='';
        }
      }
    },
    refreshPlayerCardColors(){
      const cards=this.$?.playerList?.querySelectorAll('[data-player-card]');
      if(!cards) return;
      cards.forEach(card=>this.syncPlayerCardColor(card));
    },
    updateSpecialsLegend(){
      const legend=this.$?.specialsLegend; if(!legend) return;
      const enabled=!(this.state.rules?.specials?.enabled===false);
      legend.dataset.disabled=enabled?'false':'true';
      const statusEl=this.$?.specialsStatus; if(statusEl) statusEl.textContent=enabled?'啟用':'停用';
      if(this.$?.gSpecials) this.$.gSpecials.style.opacity=enabled?'1':'0.25';
      const orderEl=this.$?.specialsOrder;
      if(orderEl){
        const labels={
          'own-color-jump':'跳格',
          'flight':'飛行',
          'portal':'傳送門',
          'power-up':'增益',
          'trap':'陷阱'
        };
        const order=(window.GameRules?.SPECIAL_RESOLUTION_ORDER||[]).map(key=>labels[key]||key).join(' → ');
        orderEl.textContent=order;
      }
    },
    onResize(){
      if(this._resizeTimer){ clearTimeout(this._resizeTimer); }
      this._resizeTimer=setTimeout(()=>{
        this.bootstrapBoard();
        this.redrawPieces();
        this._resizeTimer=null;
      },160);
    },
    lockInput(ms=0){
      if(this._inputUnlockTimer){ clearTimeout(this._inputUnlockTimer); this._inputUnlockTimer=null; }
      if(!(ms>0)){ this.state.inputLockUntil=0; return; }
      this.state.inputLockUntil=Date.now()+ms;
      this._inputUnlockTimer=setTimeout(()=>{ this.state.inputLockUntil=0; this._inputUnlockTimer=null; },ms);
    },
    isInputLocked(){ return Date.now()< (this.state.inputLockUntil||0); },
    showToast(message,duration=1600){
      const host=this.$?.toast; if(!host) return;
      if(!this._toast){ this._toast=document.createElement('div'); this._toast.className='toast-message'; host.appendChild(this._toast); }
      if(this._toastTimer){ clearTimeout(this._toastTimer); this._toastTimer=null; }
      if(!message){ this._toast.dataset.show='false'; this._toastTimer=setTimeout(()=>{ if(this._toast) this._toast.dataset.show='false'; },0); return; }
      this._toast.textContent=message;
      this._toast.dataset.show='true';
      this._toastTimer=setTimeout(()=>{ if(this._toast) this._toast.dataset.show='false'; },duration);
    },
    updateControlAssignments(){
      const mode=this.state.settings.keyboardMode||'shared';
      const map={};
      const fallbackFor=(targetMode,idx)=>{
        if(targetMode==='dual') return (idx<=1?'keyboard':'mouse');
        if(targetMode==='shared') return 'keyboard';
        if(targetMode==='custom') return 'keyboard';
        return 'mouse';
      };
      this.state.players.forEach((player,idx)=>{
        if(!player || !player.id) return;
        const pref=(player.control==='keyboard'||player.control==='mouse')?player.control:'auto';
        if(mode==='custom'){
          map[player.id]=(pref==='auto')?fallbackFor('shared',idx):pref;
          return;
        }
        if(pref==='keyboard'||pref==='mouse'){ map[player.id]=pref; return; }
        map[player.id]=fallbackFor(mode,idx);
      });
      this.state.controlById=map;
    },
    currentPlayer(){ return this.state.players.find(p=>p.id===this.state.turn)||null; },
    currentControlModeForTurn(){
      const player=this.currentPlayer();
      if(!player) return 'mouse';
      const mode=this.state.controlById?.[player.id];
      return mode||'mouse';
    },
    isInteractionPermitted(source){
      if(source==='system') return true;
      if(this.isInputLocked()){ return false; }
      const current=this.currentPlayer();
      if(current && this.state.disabledColors && this.state.disabledColors[current.id]) return false;
      const globalMode=this.state.settings?.keyboardMode||'shared';
      if(globalMode==='shared') return true;
      const control=this.currentControlModeForTurn();
      if(control==='keyboard' && source==='mouse') return false;
      if(control==='mouse' && source==='keyboard') return false;
      return true;
    },
    handleBlockedInteraction(source){
      const player=this.currentPlayer();
      if(this.isInputLocked()){ this.showToast('請稍候，提示顯示中…',900); return; }
      if(!player) return;
      const control=this.currentControlModeForTurn();
      if(control==='keyboard' && source==='mouse') this.showToast(`${player.name} 回合需用鍵盤操作`,1400);
      else if(control==='mouse' && source==='keyboard') this.showToast(`${player.name} 回合請用滑鼠`,1400);
    },
    renderHints(){
      const host=this.$?.hintCard; if(!host) return;
      const player=this.currentPlayer();
      host.innerHTML='';
      if(!player){
        host.innerHTML='<p class="hint-meta">等待遊戲開始…</p>';
        return;
      }
      const control=this.currentControlModeForTurn();
      const stage=this.state.bonusSelecting?'bonus':(this.state.dice==null?'roll':'move');
      const list=document.createElement('ul');
      const title=document.createElement('h3');
      title.textContent=`${player.name} 的操作提示`;
      const hints=[];
      const moveCount=Array.isArray(this.state.legalMoves)?this.state.legalMoves.length:0;
      const mode=this.state.settings.keyboardMode||'shared';
      const playerIndex=this.state.players.findIndex(p=>p.id===player.id);
      if(control==='keyboard'){
        if(stage==='roll') hints.push('按 Space 擲骰 🎲');
        if(stage==='move' || stage==='bonus'){
          if(mode==='shared' || mode==='custom'){ hints.push('用 1–4 選棋'); }
          else if(mode==='dual'){
            if(playerIndex===0) hints.push('P1：用 1–4 選棋');
            else if(playerIndex===1) hints.push('P2：用 7–0 選棋');
            else hints.push('自選鍵盤：用 1–4 選棋');
          }
        }
        if(stage==='move'){
          if(moveCount>0) hints.push('選擇數字鍵執行移動');
          else hints.push('沒有可移動棋子，等待換手');
        }
        if(stage==='bonus'){
          const desc=this.state.pendingBonus?.description||'使用增益移動';
          hints.push(desc);
          if(moveCount>0) hints.push('選擇符合條件的棋子以完成增益');
          else hints.push('沒有可用的增益移動，稍後自動結束');
        }
        if(this.state.rules?.undoEnabled) hints.push('按 U 撤銷 (Undo)');
      }else{
        if(stage==='roll') hints.push('點擊「擲骰 🎲」開始');
        if(stage==='move'){
          if(moveCount>0) hints.push('點擊棋子或右側按鈕移動');
          else hints.push('目前沒有可行動的棋子');
        }
        if(stage==='bonus'){
          const desc=this.state.pendingBonus?.description||'執行增益移動';
          hints.push(desc);
          if(moveCount>0) hints.push('點擊符合條件的棋子完成增益');
          else hints.push('增益沒有可移動的棋子，稍後會自動略過');
        }
        if(this.state.rules?.undoEnabled) hints.push('如需撤銷，可點 Undo 按鈕');
      }
      hints.forEach(text=>{ const li=document.createElement('li'); li.textContent=text; list.appendChild(li); });
      const totalPieces=Math.max(1, window.GameRules?.BOARD?.bases?.perPlayer||1);
      const playerPieces=this.state.pieces[player.id]||[];
      const finishedCount=playerPieces.filter(pc=>pc.pos?.kind==='finished').length;
      const finishIdx=Array.isArray(this.state.finishOrder)?this.state.finishOrder.indexOf(player.id):-1;
      const finishText=finishedCount>=totalPieces && finishIdx>=0 ? `完成 ${finishedCount}/${totalPieces} · 第 ${finishIdx+1} 名` : `完成 ${finishedCount}/${totalPieces}`;
      const meta=document.createElement('div');
      meta.className='hint-meta';
      meta.textContent=`${control==='keyboard'?'此回合鎖定鍵盤操作':'此回合鎖定滑鼠操作'} · ${finishText}`;
      host.appendChild(title);
      host.appendChild(list);
      host.appendChild(meta);
    },
    applyTheme(){
      const allowed=['dark','light','high'];
      const theme=allowed.includes(this.state.settings?.theme)?this.state.settings.theme:'dark';
      this.state.settings.theme=theme;
      if(this.$.theme && this.$.theme.value!==theme) this.$.theme.value=theme;
      document.body.dataset.theme=theme;
    },
    renderLastMove(){
      const card=this.$?.lastMoveCard;
      if(!card) return;
      const summaryEl=this.$?.lastMoveSummary;
      const metaEl=this.$?.lastMoveMeta;
      const capturedEl=this.$?.lastMoveCaptured;
      const button=this.$?.btnReplayLast;
      const summary=this.state.lastMoveSummary;
      const resetStyles=()=>{
        card.dataset.empty='true';
        card.dataset.hasSummary='false';
        card.style.removeProperty('--last-move-accent');
        card.style.removeProperty('--last-move-accent-soft');
      };
      if(!summary){
        if(summaryEl){ summaryEl.textContent='尚未有移動記錄。'; summaryEl.classList.add('muted'); }
        if(metaEl){ metaEl.textContent=''; metaEl.hidden=true; }
        if(capturedEl){ capturedEl.innerHTML=''; capturedEl.hidden=true; }
        if(button) button.disabled=true;
        resetStyles();
        return;
      }
      const colorNameMap={red:'紅',blue:'藍',yellow:'黃',green:'綠'};
      const player=summary.player||{};
      const diceText=typeof summary.dice==='number'?`擲出 ${summary.dice}`:'';
      const desc=summary.description||'完成移動';
      const colorLabel=colorNameMap[player.color]||player.color||'';
      if(summaryEl){
        const colorDisplay=colorLabel?`（${colorLabel}）`:'';
        const diceDisplay=diceText?` ${diceText}`:'';
        summaryEl.textContent=`${player.name||'玩家'}${colorDisplay}${diceDisplay}：${desc}`;
        summaryEl.classList.remove('muted');
      }
      const metaBits=[];
      if(Array.isArray(summary.path) && summary.path.length>0){ metaBits.push(`路徑節點 ${summary.path.length}`); }
      if(summary.stackSize && summary.stackSize>1){ metaBits.push(`疊子 ×${summary.stackSize}`); }
      if(metaEl){
        metaEl.textContent=metaBits.join(' · ');
        metaEl.hidden=metaBits.length===0;
      }
      if(capturedEl){
        capturedEl.innerHTML='';
        const capturedList=Array.isArray(summary.captured)?summary.captured:[];
        if(capturedList.length>0){
          capturedList.forEach(info=>{
            const li=document.createElement('li');
            const label=colorNameMap[info?.color]||info?.color||'敵機';
            li.textContent=`擊落 ${label}`;
            capturedEl.appendChild(li);
          });
          capturedEl.hidden=false;
        }else{
          capturedEl.hidden=true;
        }
      }
      if(button) button.disabled=false;
      card.dataset.empty='false';
      card.dataset.hasSummary='true';
      const accentVar=player.color?`var(--${player.color})`:'var(--accent)';
      const ghostVar=player.color?`var(--${player.color}-ghost)`:'rgba(34,211,238,0.18)';
      card.style.setProperty('--last-move-accent',accentVar);
      card.style.setProperty('--last-move-accent-soft',ghostVar);
    },
    previewLastMove(force=false){
      const summary=this.state.lastMoveSummary;
      if(!summary || !Array.isArray(summary.path) || summary.path.length===0) return;
      if(!force){
        const deciding = (this.state.bonusSelecting===true) || (this.state.dice!=null && Array.isArray(this.state.legalMoves) && this.state.legalMoves.length>0);
        if(deciding) return;
      }
      const pieceIndex=typeof summary.pieceIndex==='number'?summary.pieceIndex:0;
      this.previewMove({path:summary.path,pieceIndex}, summary.player?.color||null);
    },
    buildTurnPrompt(){
      const player=this.currentPlayer();
      if(!player) return '';
      const control=this.currentControlModeForTurn();
      const stage=this.state.bonusSelecting?'bonus':(this.state.dice==null?'roll':'move');
      let action='準備中';
      if(stage==='roll') action = control==='keyboard' ? '按 Space 擲骰 🎲' : '點擊 🎲 擲骰';
      else if(stage==='move') action = control==='keyboard' ? '用數字鍵選棋' : '點擊棋子行動';
      else if(stage==='bonus') action = control==='keyboard' ? '用數字鍵觸發增益' : '選擇棋子完成增益';
      else action='等待下一步';
      const totalPieces=Math.max(1, window.GameRules?.BOARD?.bases?.perPlayer||1);
      const pcs=this.state.pieces[player.id]||[];
      const finishedCount=pcs.filter(pc=>pc.pos?.kind==='finished').length;
      let status='';
      if(finishedCount>=totalPieces){
        const placeIdx=(Array.isArray(this.state.finishOrder)?this.state.finishOrder.indexOf(player.id):-1);
        status=placeIdx>=0?`已完成（第 ${placeIdx+1} 名）`:'已完成';
      }else{
        status=`完成 ${finishedCount}/${totalPieces}`;
      }
      return `${player.name} 的回合 — ${action}（${status}）`;
    },
    showTurnPrompt(message,{duration=2200,force=false,lock=0}={}){
      const host=this.$?.turnBanner; if(!host) return;
      if(!message){ host.dataset.show='false'; host.setAttribute('hidden',''); this._currentPrompt=''; return; }
      if(!force && this._currentPrompt===message) return;
      this._currentPrompt=message;
      host.textContent=message;
      host.dataset.show='true';
      host.removeAttribute('hidden');
      if(this._turnBannerTimer){ clearTimeout(this._turnBannerTimer); }
      this._turnBannerTimer=setTimeout(()=>{
        host.dataset.show='false';
        this._turnBannerTimer=setTimeout(()=>{ host.setAttribute('hidden',''); },220);
      },duration);
      if(lock>0) this.lockInput(lock);
    },
    updateTurnPrompt(force=false){
      const msg=this.buildTurnPrompt();
      const stage=this.state.bonusSelecting?'bonus':(this.state.dice==null?'roll':'move');
      const lock=force && stage==='roll'?320:0;
      if(msg) this.showTurnPrompt(msg,{force,duration:2200,lock});
      else this.showTurnPrompt('',{force:true});
    },
    log(message){
      const host=this.$?.log; if(!host) return;
      const entry=document.createElement('div');
      const time=new Date().toLocaleTimeString('zh-HK',{hour12:false});
      entry.textContent=`[${time}] ${message}`;
      host.appendChild(entry);
      while(host.childElementCount>80){ host.removeChild(host.firstChild); }
      host.scrollTop=host.scrollHeight;
    },
    getAnimDuration(base){
      const speed=(this.state.rules?.animSpeed)||'normal';
      if(speed==='slow') return Math.round(base*1.35);
      if(speed==='fast') return Math.round(base*0.65);
      return base;
    },
    clearTurnTimer(){
      if(this.state.turnTimerId){ clearTimeout(this.state.turnTimerId); this.state.turnTimerId=null; }
      this.state.turnTimerRemaining=0;
      if(this.$?.timer) this.$.timer.textContent='';
    },
    beginTurnTimer(){
      const secs=Number(this.state.rules?.turnTimerSec||0);
      if(!(secs>0)){ this.clearTurnTimer(); return; }
      this.clearTurnTimer();
      this.state.turnTimerRemaining=secs;
      const tick=()=>{
        if(!this.$?.timer) return;
        this.$.timer.textContent=`⏱️ ${Math.max(0,this.state.turnTimerRemaining)}s`;
        if(this.state.turnTimerRemaining<=0){
          this.state.turnTimerId=null;
          this.handleTurnTimerExpired();
          return;
        }
        this.state.turnTimerRemaining-=1;
        this.state.turnTimerId=setTimeout(tick,1000);
      };
      tick();
    },
    handleTurnTimerExpired(){
      const player=this.currentPlayer();
      if(!player) return;
      this.log(`${player.name} 超時！`);
      if(this.state.dice==null){
        this.rollDice('system');
      }else{
        this.log('回合已自動結束');
        this.advanceTurn();
      }
    },
    refreshLegalMoves(){
      if(!this.state.rules){ this.state.legalMoves=[]; this.highlightMovables(); return; }
      if(this.state.dice==null){
        this.state.legalMoves=[];
      }else{
        const snapshot={players:this.state.players,pieces:this.state.pieces,turn:this.state.turn};
        this.state.legalMoves=window.GameRules.generateLegalMoves(snapshot,this.state.rules,this.state.dice);
      }
      if(this.state.bonusSelecting && this.state.pendingBonus && Array.isArray(this.state.legalMoves)){
        const pb=this.state.pendingBonus;
        this.state.legalMoves=this.state.legalMoves.filter(m=>{
          if(pb.restrict==='same') return m.pieceIndex===pb.pieceIndex;
          if(pb.restrict==='others') return m.pieceIndex!==pb.pieceIndex;
          return true;
        });
      }
      this.highlightMovables();
    },
    handleNoMoves(player){
      this.clearTurnTimer();
      const name=player?.name||'該玩家';
      this.showTurnPrompt(`${name} 無步可走`,{duration:1600,force:true,lock:400});
      this.renderHints();
      if(this._noMoveTimer){ clearTimeout(this._noMoveTimer); }
      this._noMoveTimer=setTimeout(()=>{
        this._noMoveTimer=null;
        this.advanceTurn();
      },1200);
    },
    updateTurnUI(){
      const player=this.currentPlayer();
      this.$.turn.textContent=player?`當前：${player.name}`:'當前：—';
      this.$.btnRoll.disabled=this.state.animating||this.state.dice!=null;
      const canUndo=!!(this.state.rules?.undoEnabled && Array.isArray(this.state.history) && this.state.history.length>0);
      this.$.btnUndo.disabled=!canUndo;
      this.$.diceOut.textContent=this.state.dice==null?'–':String(this.state.dice);
      if(player && this.state.turnTimerId==null && this.state.dice==null){
        this.beginTurnTimer();
      }
      this.refreshLegalMoves();
      this.renderHints();
      this.updateTurnPrompt();
    },
    cloneDefaultRules(extra={}){
      const base=window.GameRules?.DEFAULT_RULES||{};
      const copy=(window.structuredClone? structuredClone(base) : JSON.parse(JSON.stringify(base)));
      return Object.assign(copy,extra||{});
    },
    renderLobbyPlayers(n){
      const host=this.$.playerList; if(!host) return; host.innerHTML='';
      const colors=['red','blue','yellow','green'];
      for(let i=0;i<n;i++){
        const tpl=document.getElementById('tpl-player-card'); const fragment=tpl.content.cloneNode(true);
        const card=fragment.querySelector('[data-player-card]');
        const idxLabel=fragment.querySelector('[data-idx]');
        if(idxLabel) idxLabel.textContent=i+1;
        const nameInput=fragment.querySelector('[data-name]');
        if(nameInput) nameInput.value = i===0?'Mandy':(i===1?'Brian':'');
        const colorValue=colors[i%colors.length];
        const colorSelect=fragment.querySelector('[data-color]');
        if(colorSelect) colorSelect.value=colorValue;
        const typeSelect=fragment.querySelector('[data-type]');
        if(typeSelect) typeSelect.value = (i<2?'human':'ai');
        if(card) card.dataset.color=colorValue;
        const controlSelect=fragment.querySelector('[data-control]');
        if(controlSelect){ controlSelect.value='auto'; }
        host.appendChild(fragment);
      }
      this.refreshPlayerCardColors();
      this.updateBoardOverlay();
    },
    applyPreset(name){
      if(name==='classic') this.state.rules = this.cloneDefaultRules({takeoff:'six'});
      else if(name==='fast') this.state.rules = this.cloneDefaultRules({takeoff:'fiveOrSix'});
      else this.state.rules = this.cloneDefaultRules();
      this.applyBoardDefaultsToRules();
      this.updateSpecialsLegend();
    },
    applyBoardDefaultsToRules(){
      if(!this.state.rules) return;
      const extras=window.GameRules.BOARD.special?.safeTiles?.extra||[];
      const safeRaw=this.state.rules.safeTiles||{};
      const merged=new Set([...(safeRaw.list||[]), ...extras]);
      const safe={ start:(safeRaw.start!==false), list:Array.from(merged).sort((a,b)=>a-b) };
      this.state.rules.safeTiles=safe;
      const specialsRaw=this.state.rules.specials||{};
      const specials=Object.assign({},specialsRaw);
      if(typeof specials.portalLimit!=='number' || Number.isNaN(specials.portalLimit)) specials.portalLimit=1;
      if(typeof specials.enabled!=='boolean') specials.enabled=true;
      this.state.rules.specials=specials;
    },
    readRulesFromForm(){
      const f=this.$.formSetup; const chk=n=>!!f.querySelector(`[name="${n}"]`)?.checked; const val=n=>f.querySelector(`[name="${n}"]:checked`)?.value; const num=(n,d)=>{const x=parseInt(f.querySelector(`[name="${n}"]`)?.value??d,10); return isNaN(x)?d:x;};
      return {
        takeoff: val('takeoff')||'even', extraTurnOnSix:chk('extraTurnOnSix'), tripleSixPenalty:chk('tripleSixPenalty'),
        captureOnLand:chk('captureOnLand'), stackEnabled:chk('stackEnabled'), stackMovesTogether:chk('stackMovesTogether'), blockadePassThrough:chk('blockadePassThrough'),
        ownColorJump:{enabled:chk('ownColorJumpEnabled'),steps:num('ownColorJumpSteps',4)}, dashedFlight:{enabled:chk('dashedFlightEnabled'),captureOnLanding:chk('captureOnFlight')},
        homeLaneExactEntry:chk('homeLaneExactEntry'), finishExact:(f.querySelector('[name="finishExact"]')?.value)||'exact',
        safeTiles:{start:chk('startTileSafe'),list:[]},
        specials:{enabled:chk('specialsEnabled'),portalLimit:1},
        turnTimerSec:Math.max(0,num('turnTimerSec',0)),
        animSpeed:(()=>{ const raw=(f.querySelector('[name="animSpeed"]')?.value)||'normal'; return ['slow','normal','fast'].includes(raw)?raw:'normal'; })(),
        undoEnabled:chk('undoEnabled')
      };
    },
    normalizePieces(){
      for(const player of this.state.players){
        const pcs=Array.isArray(this.state.pieces[player.id])?this.state.pieces[player.id]:[];
        if(!this.state.finishedSlots) this.state.finishedSlots={};
        if(!this.state.finishedSlots[player.id]) this.state.finishedSlots[player.id]={};
        const finishedMap=this.state.finishedSlots[player.id];
        pcs.forEach((pc,idx)=>{
          if(typeof pc.baseSlot!=='number') pc.baseSlot=idx;
          if(pc.pos?.kind==='base' && typeof pc.pos.slot!=='number') pc.pos.slot=pc.baseSlot;
          if(pc.pos?.kind==='finished'){
            if(typeof finishedMap[idx]!=='number'){
              const used=new Set(Object.values(finishedMap));
              let nextSlot=0;
              while(used.has(nextSlot) && nextSlot<4){ nextSlot+=1; }
              finishedMap[idx]=nextSlot;
            }
            pc.finishedSlot=finishedMap[idx];
          }else{
            if(finishedMap) delete finishedMap[idx];
            delete pc.finishedSlot;
          }
        });
        this.state.pieces[player.id]=pcs;
      }
    },
    normalizePlayerControls(){
      if(!Array.isArray(this.state.players)) return;
      this.state.players=this.state.players.map(player=>{
        if(!player || typeof player!=='object') return player;
        const control=(player.control==='keyboard'||player.control==='mouse')?player.control:'auto';
        return Object.assign({},player,{control});
      });
    },
    startGame(){
      // players
      const cards=this.$.playerList.querySelectorAll('[data-player-card]'); const players=[]; const seen=new Set(); const duplicateColors=new Set();
      cards.forEach((card,idx)=>{
        const name=card.querySelector('[data-name]').value||`玩家${idx+1}`;
        const color=(card.querySelector('[data-color]')?.value||'').trim();
        const type=card.querySelector('[data-type]').value||'human';
        const controlRaw=card.querySelector('[data-control]')?.value||'auto';
        const control=(controlRaw==='keyboard'||controlRaw==='mouse')?controlRaw:'auto';
        if(color && seen.has(color)){
          duplicateColors.add(color);
          return;
        }
        if(color){
          seen.add(color);
          players.push({id:`P${idx+1}`,name,color,type,control});
        }
      });
      if(duplicateColors.size>0){
        this.showToast('⚠️ 玩家顏色不可重複，請為每位玩家選擇不同顏色');
        this.log('玩家顏色不可重複，請調整後再開始');
        this.updateBoardOverlay();
        return;
      }
      if(players.length<2){ this.showToast('請至少設定 2 位擁有不同顏色的玩家'); this.log('至少需要 2 位玩家'); this.updateBoardOverlay(); return; }
      this.state.players=players; this.normalizePlayerControls(); this.state.turn=players[0].id; this.state.history=[]; this.state.pieces={};
      this.state.consecutiveSixes={};
      this.state.skipTurns={};
      this.state.bonusSelecting=false;
      this.state.pendingBonus=null;
      this.state.lastMoveSummary=null;
      this.state.finishOrder=[];
      this.state.winner=null;
      this.state.disabledColors={};
      this.state.finishedSlots={};
      this.updateControlAssignments();
      const preset=(this.$.formSetup.querySelector('input[name="preset"]:checked')?.value)||'classic';
      if(preset==='custom'){ this.state.rules = this.cloneDefaultRules(this.readRulesFromForm()); this.applyBoardDefaultsToRules(); }
      else { this.applyPreset(preset); }
      const pieceCount=window.GameRules.BOARD.bases.perPlayer||1;
      for(const p of players){
        this.state.pieces[p.id]=Array.from({length:pieceCount},(_,idx)=>({pos:window.GameRules.Pos.base(idx), baseSlot:idx}));
        this.state.consecutiveSixes[p.id]=0;
        this.state.skipTurns[p.id]=0;
      }
      this.normalizePieces();
      this.state.legalMoves=[]; this.state.animating=false; this.state.dice=null;
      this.$.diceOut.textContent='–';
      this.$.movables.innerHTML='';
      this.$.gHL.innerHTML='';
      this.$.log.innerHTML='';
      this.renderLastMove();
      this.clearGhostPath();
      this.clearTurnTimer();
      this.toGame(); this.bootstrapBoard(); this.redrawPieces(); this.updateTurnUI(); this.updateTurnPrompt(true); this.saveGame(); this.log('遊戲開始！');
      const toastMsg=this._pendingToast||'新局開始，祝你順風！';
      if(toastMsg) this.showToast(toastMsg);
      this._pendingToast=null;
      this.maybeAutoPlayIfAI();
      this.$.btnContinue.disabled=false;
    },
    toGame(){
      this.state.view='game';
      this.updateViewVisibility();
      this.updateBoardOverlay();
      this.updateSpecialsLegend();
    },
    toLobby(){
      this.state.view='lobby';
      this.updateViewVisibility();
      this.updateBoardOverlay();
      this.updateSpecialsLegend();
      this.clearTurnTimer();
      const existingCount=Array.isArray(this.state.players)?this.state.players.length:0;
      const count=existingCount>0?existingCount:(parseInt(this.$?.playerCount?.value||'2',10)||2);
      if(this.$?.playerCount) this.$.playerCount.value=String(count);
      this.renderLobbyPlayers(count);
      const cards=this.$?.playerList?.querySelectorAll('[data-player-card]');
      if(cards){
        this.state.players?.forEach((player,idx)=>{
          const card=cards[idx];
          if(!card) return;
          const nameInput=card.querySelector('[data-name]');
          if(nameInput) nameInput.value=player.name||`玩家${idx+1}`;
          const colorSelect=card.querySelector('[data-color]');
          if(colorSelect && player.color){ colorSelect.value=player.color; }
          const typeSelect=card.querySelector('[data-type]');
          if(typeSelect && player.type){ typeSelect.value=player.type; }
          const controlSelect=card.querySelector('[data-control]');
          if(controlSelect && player.control){ controlSelect.value=player.control; }
        });
        this.refreshPlayerCardColors();
      }
    },

    restartGame(){
      if(!Array.isArray(this.state.players) || this.state.players.length<2){
        this.log('未有進行中的對局');
        return;
      }
      this.updateControlAssignments();
      const pieceCount=window.GameRules.BOARD.bases.perPlayer||1;
      this.state.pieces={};
      this.state.consecutiveSixes={};
      this.state.skipTurns={};
      this.state.bonusSelecting=false;
      this.state.pendingBonus=null;
      this.state.lastMoveSummary=null;
      this.state.finishOrder=[];
      this.state.winner=null;
      this.state.disabledColors={};
      this.state.finishedSlots={};
      for(const p of this.state.players){
        this.state.pieces[p.id]=Array.from({length:pieceCount},(_,idx)=>({pos:window.GameRules.Pos.base(idx), baseSlot:idx}));
        this.state.consecutiveSixes[p.id]=0;
        this.state.skipTurns[p.id]=0;
      }
      this.normalizePieces();
      this.state.turn=this.state.players[0].id;
      this.state.history=[];
      this.state.legalMoves=[];
      this.state.animating=false;
      this.state.dice=null;
      this.$.diceOut.textContent='–';
      this.$.movables.innerHTML='';
      this.$.gHL.innerHTML='';
      this.$.log.innerHTML='';
      this.renderLastMove();
      this.clearGhostPath();
      this.clearTurnTimer();
      this.toGame();
      this.bootstrapBoard();
      this.redrawPieces();
      this.updateTurnUI();
      this.updateTurnPrompt(true);
      this.saveGame();
      this.log('已重開新局');
      const toastMsg=this._pendingToast||'新局已重置';
      if(toastMsg) this.showToast(toastMsg);
      this._pendingToast=null;
      this.maybeAutoPlayIfAI();
      this.$.btnContinue.disabled=false;
      this.updateSpecialsLegend();
    },

    rollDice(source='system'){
      if(this.state.view!=='game'){ return; }
      if(!this.isInteractionPermitted(source)){ this.handleBlockedInteraction(source); return; }
      if(this.state.animating){ this.log('動畫進行中，稍候再擲'); return; }
      if(this.state.bonusSelecting){ this.showToast('先完成增益移動',1200); return; }
      if(this.state.dice!=null){ this.log('本回合已擲骰'); return; }
      const player=this.currentPlayer();
      if(!player){ return; }
      const skipRemaining=Math.max(0,this.state.skipTurns?.[player.id]||0);
      if(skipRemaining>0){
        this.state.skipTurns[player.id]=skipRemaining-1;
        this.log(`${player.name} 因亂流停飛，跳過此回合擲骰`);
        this.showToast(`${player.name} 暫停一回合`,1200);
        this.state.legalMoves=[];
        this.highlightMovables();
        this.renderHints();
        this.updateTurnPrompt(true);
        this.advanceTurn();
        return;
      }
      const value=1+Math.floor(Math.random()*6);
      this.state.dice=value;
      this.$.diceOut.textContent=String(value);
      this.log(`${player.name} 擲出 ${value}`);
      const pid=player.id;
      const prev=this.state.consecutiveSixes?.[pid]||0;
      if(!this.state.consecutiveSixes) this.state.consecutiveSixes={};
      if(value===6){ this.state.consecutiveSixes[pid]=prev+1; }
      else { this.state.consecutiveSixes[pid]=0; }
      if(value===6 && this.state.rules?.tripleSixPenalty && this.state.consecutiveSixes[pid]>=3){
        this.log(`${player.name} 連續三次擲出 6，被判失去回合`);
        this.state.consecutiveSixes[pid]=0;
        this.state.dice=null;
        this.$.diceOut.textContent='–';
        this.state.legalMoves=[];
        this.highlightMovables();
        this.renderHints();
        this.clearTurnTimer();
        this.updateTurnPrompt(true);
        this.advanceTurn();
        return;
      }
      this.refreshLegalMoves();
      this.renderHints();
      this.saveGame();
      const moveCount=(this.state.legalMoves||[]).length;
      if(moveCount===0){
        this.log(`${player.name} 無步可走`);
        this.handleNoMoves(player);
        return;
      }
      this.clearTurnTimer();
      this.beginTurnTimer();
      this.updateTurnPrompt(true);
      this.maybeAutoPlayIfAI();
    },

    // --------- Board Rendering ---------

    bootstrapBoard(){
      const svg=this.$.svg; const W=1000,H=1000; svg.setAttribute('viewBox',`0 0 ${W} ${H}`); const cx=W/2,cy=H/2,r=380;
      const gBack=this.$.gBack,gGrid=this.$.gGrid,gTiles=this.$.gTiles,gSpecials=this.$.gSpecials,gHud=this.$.gHud,gPieces=this.$.gPieces,gHL=this.$.gHL;
      if(gBack) gBack.innerHTML='';
      if(gGrid) gGrid.innerHTML='';
      gTiles.innerHTML=gSpecials.innerHTML=gPieces.innerHTML=gHL.innerHTML='';
      if(gHud){
        gHud.innerHTML='';
        const hudStatic=document.createElementNS(SVG_NS,'g');
        hudStatic.setAttribute('class','hud-static');
        const hudDynamic=document.createElementNS(SVG_NS,'g');
        hudDynamic.setAttribute('class','hud-dynamic');
        gHud.appendChild(hudStatic);
        gHud.appendChild(hudDynamic);
        this._hudLayers={static:hudStatic,dynamic:hudDynamic};
      }else{
        this._hudLayers={static:null,dynamic:null};
      }
      const existingDefs=svg.querySelector('defs');
      if(existingDefs) svg.removeChild(existingDefs);
      const defs=document.createElementNS(SVG_NS,'defs');
      svg.insertBefore(defs,svg.firstChild);
      const el=(n,a={},children=[])=>{ const node=document.createElementNS(SVG_NS,n); for(const [k,v] of Object.entries(a)){ node.setAttribute(k,String(v)); } children.forEach(child=>node.appendChild(child)); return node; };
      const planeShape=el('g',{id:'plane-shape','vector-effect':'non-scaling-stroke'},[
        el('path',{d:'M0,-9 L6,0 L0,-3 L-6,0 Z',fill:'currentColor'}),
        el('rect',{x:-4,y:0,width:8,height:6,rx:2,ry:2,fill:'currentColor'})
      ]);
      defs.appendChild(planeShape);
      const finishBadge=el('g',{id:'finish-badge'},[
        el('circle',{r:10,cx:0,cy:0,fill:'rgba(15,23,42,0.82)',stroke:'rgba(255,255,255,0.82)','stroke-width':2}),
        el('path',{d:'M -4 0 L -1 3 L 5 -3',stroke:'#fff','stroke-width':2.2,fill:'none','stroke-linecap':'round','stroke-linejoin':'round'})
      ]);
      defs.appendChild(finishBadge);
      const glow=el('filter',{id:'glow',x:'-50%',y:'-50%',width:'200%',height:'200%'});
      const blur=document.createElementNS(SVG_NS,'feGaussianBlur');
      blur.setAttribute('stdDeviation','3.5');
      blur.setAttribute('result','coloredBlur');
      const merge=document.createElementNS(SVG_NS,'feMerge');
      const mergeNode1=document.createElementNS(SVG_NS,'feMergeNode');
      mergeNode1.setAttribute('in','coloredBlur');
      const mergeNode2=document.createElementNS(SVG_NS,'feMergeNode');
      mergeNode2.setAttribute('in','SourceGraphic');
      merge.appendChild(mergeNode1);
      merge.appendChild(mergeNode2);
      glow.appendChild(blur);
      glow.appendChild(merge);
      defs.appendChild(glow);
      const css=getComputedStyle(document.documentElement);
      const color=(name)=>css.getPropertyValue(name).trim();
      const geom=this.geom={track:[],home:{},bases:{},runway:{},finishedSlots:{},baseCenters:{},runwayEntry:{}};
      const isCompact=window.matchMedia('(max-width: 959px)').matches;
      const parseHex=(hex)=>{ const h=hex.replace('#',''); const parts=h.length===3?h.split('').map(c=>parseInt(c+c,16)):h.match(/.{2}/g).map(v=>parseInt(v,16)); return{r:parts[0],g:parts[1],b:parts[2]}; };
      const mixWithWhite=(hex,amount)=>{ const {r,g,b}=parseHex(hex); const mix=c=>Math.round(c+(255-c)*amount); return`rgb(${mix(r)},${mix(g)},${mix(b)})`; };
      const withAlpha=(hex,alpha)=>{ const {r,g,b}=parseHex(hex); return`rgba(${r},${g},${b},${alpha})`; };
      const rad=(deg)=>deg*Math.PI/180;
      const trackRadius=r-20;
      const ringPoint=(i,total=window.GameRules.BOARD.track.length)=>{ const radial=(Math.PI*2)*(i/total)-Math.PI/2; const tangent=radial+Math.PI/2; return{ x:cx+Math.cos(radial)*trackRadius, y:cy+Math.sin(radial)*trackRadius, radial, tangent }; };
      const arcPath=(centerX,centerY,rInner,rOuter,startDeg,endDeg)=>{
        const startRad=rad(startDeg);
        const endRad=rad(endDeg);
        const outerStart={x:centerX+Math.cos(startRad)*rOuter,y:centerY+Math.sin(startRad)*rOuter};
        const outerEnd={x:centerX+Math.cos(endRad)*rOuter,y:centerY+Math.sin(endRad)*rOuter};
        const innerEnd={x:centerX+Math.cos(endRad)*rInner,y:centerY+Math.sin(endRad)*rInner};
        const innerStart={x:centerX+Math.cos(startRad)*rInner,y:centerY+Math.sin(startRad)*rInner};
        const sweep=Math.abs(endDeg-startDeg)>180?1:0;
        return`M ${outerStart.x} ${outerStart.y} A ${rOuter} ${rOuter} 0 ${sweep} 1 ${outerEnd.x} ${outerEnd.y} L ${innerEnd.x} ${innerEnd.y} A ${rInner} ${rInner} 0 ${sweep} 0 ${innerStart.x} ${innerStart.y} Z`;
      };
      const starPoints=(centerX,centerY,outer,inner)=>{
        const pts=[];
        for(let i=0;i<10;i++){
          const angle=(Math.PI/2)+(i*Math.PI/5);
          const radius=(i%2===0)?outer:inner;
          const px=centerX+Math.cos(angle)*radius;
          const py=centerY-Math.sin(angle)*radius;
          pts.push(`${px},${py}`);
        }
        return pts.join(' ');
      };
      const drawChevron=(group,x,y,a,size=10)=>{
        const x1=x+Math.cos(a)*(size*1.2);
        const y1=y+Math.sin(a)*(size*1.2);
        group.appendChild(el('path',{
          d:`M ${x1} ${y1} l ${-Math.cos(a+0.8)*size/1.5} ${-Math.sin(a+0.8)*size/1.5} M ${x1} ${y1} l ${-Math.cos(a-0.8)*size/1.5} ${-Math.sin(a-0.8)*size/1.5}`,
          class:'tile-icon',stroke:'rgba(255,255,255,.28)','stroke-linecap':'round'
        }));
      };
      const drawQuadrant=(startDeg,endDeg,colorHex,label)=>{
        if(gBack){
          const path=arcPath(cx,cy,trackRadius-50,trackRadius+46,startDeg,endDeg);
          gBack.appendChild(el('path',{d:path,fill:withAlpha(colorHex,0.08)}));
        }
        const hudStatic=this._hudLayers?.static;
        if(hudStatic){
          const mid=(startDeg+endDeg)/2;
          const rx=cx+Math.cos(rad(mid))*(trackRadius+52);
          const ry=cy+Math.sin(rad(mid))*(trackRadius+52);
          hudStatic.appendChild(el('text',{x:rx,y:ry,'text-anchor':'middle','dominant-baseline':'central','font-size':12,'fill':withAlpha(colorHex,0.38),'font-weight':'600'},[document.createTextNode(label)]));
        }
      };
      const tooltipFor=(info)=>{
        if(!info) return '';
        const colorLabel={red:'紅',blue:'藍',yellow:'黃',green:'綠'};
        if(info.type==='safe') return '安全格：不可被吃';
        if(info.type==='start') return `${colorLabel[info.color]||''} 起飛格`;
        if(info.type==='jump') return `${colorLabel[info.color]||''} 跳格入口`;
        if(info.type==='portal') return `傳送門 ${info.label}: ${info.from} → ${info.to}`;
        if(info.type==='power'){
          if(info.effect==='extra-roll') return '增益：再擲一次';
          if(info.effect==='advance-2') return '增益：前進 2 格';
          if(info.effect==='command-other') return '增益：指揮其他棋 +1';
          return '增益格';
        }
        if(info.type==='trap'){
          if(info.effect==='skip-turn') return '陷阱：下回合停飛';
          return '陷阱格';
        }
        return '';
      };
      if(gBack){
        gBack.appendChild(el('circle',{cx,cy,r:r+60,fill:'#0a0a0a',stroke:withAlpha(color('--tile-grid'),0.6),'stroke-width':2,opacity:.5}));
      }
      const quadrants=[
        {label:'R',color:color('--red'),start:-135,end:-45},
        {label:'B',color:color('--blue'),start:-45,end:45},
        {label:'Y',color:color('--yellow'),start:45,end:135},
        {label:'G',color:color('--green'),start:135,end:225}
      ];
      quadrants.forEach(q=>drawQuadrant(q.start,q.end,q.color,q.label));
      const total=window.GameRules.BOARD.track.length; const startIdx=window.GameRules.BOARD.track.startIndex; const entryIdx=window.GameRules.BOARD.homeLane.entryIndex; const ownJump=window.GameRules.BOARD.special.ownColorJump.indices;
      const specials=window.GameRules.BOARD.special||{};
      const safeExtras=new Set((specials.safeTiles?.extra)||[]);
      const specialByIdx=window.GameRules.SPECIAL_BY_IDX||{};
      const portalPairs=new Map();
      (specials.portals||[]).forEach(p=>{
        if(!p || !p.label) return;
        if(!portalPairs.has(p.label)) portalPairs.set(p.label,new Set());
        const set=portalPairs.get(p.label);
        set.add(p.from);
        set.add(p.to);
      });
      const jumpPatterns={};
      const ensureJumpPattern=(col)=>{
        if(jumpPatterns[col]) return jumpPatterns[col];
        const hex=color(`--${col}`);
        const pattern=el('pattern',{id:`jump-${col}`,patternUnits:'userSpaceOnUse',width:10,height:10});
        pattern.appendChild(el('rect',{width:10,height:10,fill:withAlpha(hex,0.12)}));
        pattern.appendChild(el('circle',{cx:3,cy:3,r:1.4,fill:withAlpha(hex,0.35)}));
        pattern.appendChild(el('circle',{cx:8,cy:8,r:1.2,fill:withAlpha(hex,0.28)}));
        defs.appendChild(pattern); jumpPatterns[col]=pattern; return pattern;
      };
      const ownJumpLookup={}; Object.entries(ownJump).forEach(([col,arr])=>arr.forEach(idx=>{ ownJumpLookup[idx]=col; }));
      const startIndexByColor=Object.fromEntries(Object.entries(startIdx).map(([col,idx])=>[idx,col]));
      const entryIndexByColor=Object.fromEntries(Object.entries(entryIdx).map(([col,idx])=>[idx,col]));
      const tileSize=isCompact?40:44;
      const chevronData=[];
      const cardinalTargets=[0,90,180,270];
      const cardinalBest=cardinalTargets.map(()=>({idx:-1,delta:Infinity}));
      for(let i=0;i<total;i++){
        const {x,y,radial,tangent}=ringPoint(i,total);
        geom.track[i]={x,y,angle:tangent,radial};
        const tangentDeg=tangent*180/Math.PI;
        const gTile=el('g',{transform:`translate(${x} ${y})`});
        const borderGroup=el('g',{transform:`rotate(${tangentDeg})`});
        const baseAttrs={x:-tileSize/2,y:-tileSize/2,width:tileSize,height:tileSize,rx:10,fill:'transparent',stroke:withAlpha(color('--tile-grid'),0.85),'stroke-width':2};
        const jumpCol=ownJumpLookup[i];
        if(jumpCol){ const hex=color(`--${jumpCol}`); baseAttrs.fill=mixWithWhite(hex,0.16); baseAttrs.stroke=withAlpha(hex,0.65); baseAttrs['stroke-width']=2.5; }
        borderGroup.appendChild(el('rect',baseAttrs));
        if(jumpCol){ ensureJumpPattern(jumpCol); borderGroup.appendChild(el('rect',{x:-tileSize/2,y:-tileSize/2,width:tileSize,height:tileSize,rx:10,fill:`url(#jump-${jumpCol})`,opacity:0.45})); }
        gTile.appendChild(borderGroup);
        const gIcon=el('g',{transform:'rotate(0)'});
        gTile.appendChild(gIcon);
        gTiles.appendChild(gTile);
        const specialEntry=specialByIdx[i];
        const startColor=startIndexByColor[i];
        const isSafeExtra=safeExtras.has(i);
        if(isSafeExtra){
          gIcon.appendChild(el('circle',{r:tileSize*0.38,class:'tile-icon tile-ring',stroke:'#BEE3F8'}));
        }
        if(startColor){
          const hex=color(`--${startColor}`);
          gIcon.appendChild(el('circle',{r:tileSize*0.32,class:'tile-icon',stroke:withAlpha(hex,0.6),fill:'none'}));
          gIcon.appendChild(el('circle',{r:tileSize*0.18,fill:hex,stroke:'none'}));
        }
        if(specialEntry?.type==='trap'){
          gIcon.appendChild(el('rect',{x:-8,y:-8,width:16,height:16,transform:'rotate(45)',fill:'rgba(255,95,109,.25)',stroke:'rgba(255,95,109,.9)',class:'tile-icon'}));
        }else if(specialEntry?.type==='power'){
          gIcon.appendChild(el('circle',{r:5,fill:'rgba(255,255,255,.9)'}));
          gIcon.appendChild(el('circle',{r:tileSize*0.32,class:'tile-icon tile-ring',stroke:'rgba(255,255,255,.82)'}));
        }else if(specialEntry?.type==='portal'){
          const accent=color('--accent');
          gIcon.appendChild(el('circle',{r:tileSize*0.34,class:'tile-icon',stroke:withAlpha(accent,0.9),fill:'none'}));
          gIcon.appendChild(el('text',{y:1,'text-anchor':'middle','dominant-baseline':'central','font-weight':'700','font-size':14,'fill':'#fff'},[document.createTextNode(specialEntry.label||'●')]));
        }
        const tooltipCandidates=[];
        if(specialEntry) tooltipCandidates.push(tooltipFor(specialEntry));
        if(isSafeExtra) tooltipCandidates.push(tooltipFor({type:'safe'}));
        if(startColor) tooltipCandidates.push(tooltipFor({type:'start',color:startColor}));
        if(jumpCol) tooltipCandidates.push(tooltipFor({type:'jump',color:jumpCol}));
        const tooltipText=tooltipCandidates.find(Boolean);
        if(tooltipText){
          gIcon.appendChild(el('title',{},[document.createTextNode(tooltipText)]));
        }
        chevronData.push({x,y,angle:tangent,idx:i});
        const normDeg=(tangent*180/Math.PI+360)%360;
        cardinalTargets.forEach((target,ci)=>{
          const rawDiff=Math.abs(normDeg-target);
          const diff=Math.min(rawDiff,360-rawDiff);
          if(diff<cardinalBest[ci].delta){ cardinalBest[ci]={idx:i,delta:diff}; }
        });
        const hudStatic=this._hudLayers?.static;
        if(hudStatic && i%5===0){
          const tickRadius=trackRadius+16;
          const tx=cx+Math.cos(radial)*tickRadius;
          const ty=cy+Math.sin(radial)*tickRadius;
          hudStatic.appendChild(el('text',{x:tx,y:ty,'text-anchor':'middle','dominant-baseline':'central','font-size':10,'fill':'rgba(255,255,255,.7)'},[document.createTextNode(String(i))]));
        }
      }
      const cardinalSet=new Set(cardinalBest.map(entry=>entry.idx).filter(idx=>idx>=0));
      const hudStatic=this._hudLayers?.static;
      if(hudStatic){
        const chevronGroup=el('g',{class:'tile-chevron-group'});
        chevronData.forEach(({x,y,angle,idx})=>{
          const size=cardinalSet.has(idx)?18:10;
          drawChevron(chevronGroup,x,y,angle,size);
        });
        hudStatic.appendChild(chevronGroup);
      }
      if(portalPairs.size>0){
        const portalLines=el('g',{opacity:0.55});
        portalPairs.forEach((set,label)=>{
          const points=Array.from(set).map(idx=>geom.track[idx]).filter(Boolean);
          if(points.length>=2){
            const [p1,p2]=points;
            portalLines.appendChild(el('line',{x1:p1.x,y1:p1.y,x2:p2.x,y2:p2.y,stroke:color('--accent'),'stroke-dasharray':'8 6','stroke-width':2.6,'stroke-linecap':'round'}));
            const mid={x:(p1.x+p2.x)/2,y:(p1.y+p2.y)/2};
            portalLines.appendChild(el('text',{x:mid.x,y:mid.y-8,'text-anchor':'middle','font-size':'12','font-weight':'600','fill':color('--accent')},[document.createTextNode(`🌀${label}`)]));
          }
        });
        gSpecials.appendChild(portalLines);
      }
      for(const [idx,col] of Object.entries(entryIndexByColor)){
        const tile=geom.track[idx];
        if(!tile) continue;
        const dir={x:cx-tile.x,y:cy-tile.y};
        const len=Math.hypot(dir.x,dir.y)||1; const ux=dir.x/len,uy=dir.y/len;
        const outward={x:-ux,y:-uy};
        const tip={x:tile.x+ux*(tileSize*0.28),y:tile.y+uy*(tileSize*0.28)};
        const baseCenter={x:tile.x+outward.x*(tileSize*0.34),y:tile.y+outward.y*(tileSize*0.34)};
        const perp={x:-uy,y:ux}; const baseHalf=tileSize*0.24;
        const p1={x:baseCenter.x+perp.x*baseHalf,y:baseCenter.y+perp.y*baseHalf};
        const p2={x:baseCenter.x-perp.x*baseHalf,y:baseCenter.y-perp.y*baseHalf};
        gSpecials.appendChild(el('polygon',{points:`${tip.x},${tip.y} ${p1.x},${p1.y} ${p2.x},${p2.y}`,fill:withAlpha(color(`--${col}`),0.82)}));
      }
      const flights=window.GameRules.BOARD.special.flightPaths.edges; const flightGroup=el('g',{});
      const bezierTangent=(t,p0,p1,p2)=>{ const mt=1-t; return{ x:2*mt*(p1.x-p0.x)+2*t*(p2.x-p1.x), y:2*mt*(p1.y-p0.y)+2*t*(p2.y-p1.y) }; };
      for(const [ck,edges] of Object.entries(flights)){
        const strokeColor=color(`--${ck}`);
        for(const e of edges){
          const p0=geom.track[e.from]; const p2=geom.track[e.to];
          const mid={x:(p0.x+p2.x)/2,y:(p0.y+p2.y)/2};
          const vec={x:p2.x-p0.x,y:p2.y-p0.y}; const segLen=Math.hypot(vec.x,vec.y)||1; const unit={x:vec.x/segLen,y:vec.y/segLen};
          let normal={x:-unit.y,y:unit.x};
          const midFromCenter={x:mid.x-cx,y:mid.y-cy};
          if(normal.x*midFromCenter.x+normal.y*midFromCenter.y<0){ normal={x:-normal.x,y:-normal.y}; }
          const k=0.32; const control={x:mid.x+normal.x*(segLen*k), y:mid.y+normal.y*(segLen*k)};
          const path=el('path',{d:`M ${p0.x} ${p0.y} Q ${control.x} ${control.y} ${p2.x} ${p2.y}`,stroke:strokeColor,'stroke-width':4,fill:'none',opacity:.78,'stroke-linecap':'round'});
          flightGroup.appendChild(path);
          const tTip=0.985; const arrowTip={x:p2.x,y:p2.y};
          const tan=bezierTangent(tTip,p0,control,p2); const tanLen=Math.hypot(tan.x,tan.y)||1; const tanUnit={x:tan.x/tanLen,y:tan.y/tanLen};
          const arrowLen=12; const baseCenter={x:arrowTip.x-tanUnit.x*arrowLen,y:arrowTip.y-tanUnit.y*arrowLen};
          const normalVec={x:-tanUnit.y,y:tanUnit.x}; const arrowWidth=12;
          const c1={x:baseCenter.x+normalVec.x*(arrowWidth/2),y:baseCenter.y+normalVec.y*(arrowWidth/2)};
          const c2={x:baseCenter.x-normalVec.x*(arrowWidth/2),y:baseCenter.y-normalVec.y*(arrowWidth/2)};
          const arrow=el('polygon',{points:`${arrowTip.x},${arrowTip.y} ${c1.x},${c1.y} ${c2.x},${c2.y}`,fill:strokeColor,opacity:.9});
          flightGroup.appendChild(arrow);
        }
      }
      gSpecials.appendChild(flightGroup);
      const homeLen=window.GameRules.BOARD.homeLane.length; Object.entries(entryIdx).forEach(([col,idx])=>{
        const entry=geom.track[idx]; if(!entry) return;
        const dir={x:cx-entry.x,y:cy-entry.y}; const len=Math.hypot(dir.x,dir.y)||1; const ux=dir.x/len,uy=dir.y/len;
        const spacing=tileSize+10; const offset=tileSize*0.6;
        const perp={x:-uy,y:ux};
        geom.home[col]=[];
        for(let i=0;i<homeLen;i++){
          const dist=offset+i*spacing;
          const x=entry.x+ux*dist; const y=entry.y+uy*dist;
          geom.home[col][i]={x,y};
          const along=tileSize*0.5;
          const halfWidth=tileSize*0.18;
          const p1={x:x+perp.x*halfWidth+ux*along,y:y+perp.y*halfWidth+uy*along};
          const p2={x:x-perp.x*halfWidth+ux*along,y:y-perp.y*halfWidth+uy*along};
          const p3={x:x-perp.x*halfWidth-ux*along,y:y-perp.y*halfWidth-uy*along};
          const p4={x:x+perp.x*halfWidth-ux*along,y:y+perp.y*halfWidth-uy*along};
          const isGoal=i===homeLen-1;
          const fill=isGoal?withAlpha(color(`--${col}`),0.85):'rgba(148,163,184,0.18)';
          const stroke=isGoal?withAlpha(color(`--${col}`),0.85):withAlpha(color(`--${col}`),0.4);
          gTiles.appendChild(el('polygon',{points:`${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y} ${p4.x},${p4.y}`,'stroke-width':2,'stroke-linejoin':'round',stroke,fill}));
        }
      });
      if(gGrid){
        gGrid.appendChild(el('rect',{x:cx-60,y:cy-60,width:120,height:120,transform:`rotate(45 ${cx} ${cy})`,fill:'#0f172a',stroke:color('--tile-grid'),'stroke-width':2}));
        gGrid.appendChild(el('circle',{cx,cy,r:r+150,fill:'none',stroke:'#000','stroke-width':140,opacity:.35}));
      }
      gSpecials.appendChild(el('polygon',{points:starPoints(cx,cy,70,28),fill:withAlpha(color('--accent'),0.16),stroke:color('--accent'),'stroke-width':2.4}));
      const baseOffset=isCompact?300:350;
      const baseSize=isCompact?150:180;
      const slotOffset=isCompact?32:40;
      const slotRadius=isCompact?18:22;
      const baseDefs={red:{dx:-baseOffset,dy:-baseOffset},blue:{dx:baseOffset,dy:-baseOffset},yellow:{dx:baseOffset,dy:baseOffset},green:{dx:-baseOffset,dy:baseOffset}};
      geom.baseRadius=baseSize/2;
      const runwayLength=(window.GameRules && window.GameRules.BOARD && window.GameRules.BOARD.runwayLength)||4;
      const runwayPaddingFromBase=14;
      const runwayTileSize=26;
      const gRunways=el('g',{class:'runway-layer','pointer-events':'none'});
      for(const [col,{dx,dy}] of Object.entries(baseDefs)){
        const group=el('g',{});
        const x=cx+dx,y=cy+dy,w=baseSize,h=baseSize;
        geom.baseCenters[col]={x,y};
        geom.runwayEntry[col]=startIdx[col];
        group.appendChild(el('rect',{x:x-w/2,y:y-h/2,width:w,height:h,rx:isCompact?18:22,fill:withAlpha(color(`--${col}`),0.18),stroke:withAlpha(color(`--${col}`),0.6),'stroke-width':2}));
        const slots=[];
        for(let i=-1;i<=1;i+=2){
          for(let j=-1;j<=1;j+=2){
            const sx=x+i*slotOffset,sy=y+j*slotOffset;
            const label=slots.length+1;
            slots.push({x:sx,y:sy});
            group.appendChild(el('circle',{cx:sx,cy:sy,r:slotRadius,fill:'rgba(255,255,255,.10)',stroke:withAlpha(color(`--${col}`),0.65),'stroke-width':2}));
            group.appendChild(el('text',{x:sx,y:sy,'text-anchor':'middle','dominant-baseline':'central','font-size':12,'fill':withAlpha(color(`--${col}`),0.85),'font-weight':'600'},[document.createTextNode(String(label))]));
          }
        }
        geom.bases[col]=slots;
        const finishedSlotSpacing=18;
        const finishedOffsets=[
          {x:-finishedSlotSpacing,y:-finishedSlotSpacing},
          {x: finishedSlotSpacing,y:-finishedSlotSpacing},
          {x:-finishedSlotSpacing,y: finishedSlotSpacing},
          {x: finishedSlotSpacing,y: finishedSlotSpacing}
        ];
        geom.finishedSlots[col]=finishedOffsets.map(offset=>({x:x+offset.x,y:y+offset.y}));
        const startIndex=startIdx[col];
        const startTile=typeof startIndex==='number'?geom.track[startIndex]:null;
        const runwayTiles=[];
        if(startTile){
          const baseCenter={x,y};
          const heading=Math.atan2(startTile.y-baseCenter.y,startTile.x-baseCenter.x);
          const baseRadius=geom.baseRadius||24;
          const firstOffsetDist=baseRadius+runwayPaddingFromBase;
          const firstPoint={x:baseCenter.x+Math.cos(heading)*firstOffsetDist,y:baseCenter.y+Math.sin(heading)*firstOffsetDist};
          const vectorToStart={x:startTile.x-firstPoint.x,y:startTile.y-firstPoint.y};
          const segCount=Math.max(1,runwayLength-1);
          for(let i=0;i<runwayLength;i++){
            const t=(segCount===0)?1:(i/segCount);
            const px=firstPoint.x+vectorToStart.x*t;
            const py=firstPoint.y+vectorToStart.y*t;
            runwayTiles.push({x:px,y:py,heading,slotIndex:i});
          }
        }
        geom.runway[col]=runwayTiles;
        runwayTiles.forEach(tile=>{
          const deg=tile.heading*180/Math.PI;
          const gTile=el('g',{transform:`translate(${tile.x},${tile.y}) rotate(${deg})`,'data-runway-col':col,'data-runway-slot':String(tile.slotIndex)});
          const rect=el('rect',{x:-runwayTileSize/2,y:-runwayTileSize/2,width:runwayTileSize,height:runwayTileSize,rx:4,ry:4,class:`runway-tile runway-${col}`,'pointer-events':'none',stroke:withAlpha(color(`--${col}`),0.55)});
          gTile.appendChild(rect);
          gRunways.appendChild(gTile);
        });
        if(gGrid) gGrid.appendChild(group);
      }
      gSpecials.appendChild(gRunways);
      this.clearGhostPath();
    },
    clearGhostPath(){
      const layer=this._hudLayers?.dynamic;
      if(!layer) return;
      layer.querySelectorAll('.ghost-path').forEach(node=>node.remove());
    },
    buildTaxiPath(color,outboundTargetTrackIndex){
      const runway=(this.geom.runway&&this.geom.runway[color])||[];
      const path=[];
      if(Array.isArray(runway)&&runway.length>0){
        runway.forEach(tile=>{ path.push({x:tile.x,y:tile.y}); });
      }
      const finalCoord=(typeof outboundTargetTrackIndex==='number')?this.geom.track[outboundTargetTrackIndex]:outboundTargetTrackIndex;
      if(finalCoord){
        const last=path[path.length-1];
        if(!last || last.x!==finalCoord.x || last.y!==finalCoord.y){
          path.push({x:finalCoord.x,y:finalCoord.y});
        }
      }
      return path;
    },
    resolveMovePath(color,move,pieceIndex,piece=null){
      const coords=[];
      const rawPath=Array.isArray(move?.path)?move.path.slice():[];
      const fromPos=move?.from||piece?.pos||null;
      const toPos=move?.to||null;
      if(fromPos && (rawPath.length===0 || !window.GameRules.Pos.isEqual(rawPath[0],fromPos))){
        rawPath.unshift(fromPos);
      }
      if(toPos && (rawPath.length===0 || !window.GameRules.Pos.isEqual(rawPath[rawPath.length-1],toPos))){
        rawPath.push(toPos);
      }
      let skipNextTrack=false;
      for(let i=0;i<rawPath.length;i++){
        const pos=rawPath[i];
        if(skipNextTrack && pos.kind==='track'){ skipNextTrack=false; continue; }
        const xy=this.posToXY(color,pos,pieceIndex,piece);
        if(xy) coords.push({x:xy.x,y:xy.y});
        const next=rawPath[i+1];
        if(pos.kind==='base' && next && next.kind==='track'){
          const taxi=this.buildTaxiPath(color,next.idx);
          taxi.forEach(pt=>coords.push({x:pt.x,y:pt.y}));
          skipNextTrack=true;
        }
      }
      if(coords.length===0){
        const start=this.posToXY(color,fromPos||window.GameRules.Pos.base(pieceIndex||0),pieceIndex,piece);
        if(start) coords.push({x:start.x,y:start.y});
        const end=this.posToXY(color,toPos||fromPos,pieceIndex,piece);
        if(end){
          const last=coords[coords.length-1];
          if(!last || last.x!==end.x || last.y!==end.y){ coords.push({x:end.x,y:end.y}); }
        }
      }
      return coords;
    },
    previewMove(move,colorOverride=null){
      const layer=this._hudLayers?.dynamic;
      if(!layer) return;
      this.clearGhostPath();
      if(!move) return;
      const playerColor=colorOverride||this.currentPlayer()?.color;
      if(!playerColor) return;
      const coords=this.resolveMovePath(playerColor,move,move.pieceIndex);
      const points=coords.map(pt=>`${pt.x} ${pt.y}`);
      if(points.length<2) return;
      const poly=document.createElementNS(SVG_NS,'polyline');
      poly.setAttribute('points',points.join(' '));
      poly.setAttribute('fill','none');
      poly.setAttribute('stroke','rgba(255,255,255,.35)');
      poly.setAttribute('stroke-width','3');
      poly.setAttribute('stroke-linecap','round');
      poly.setAttribute('stroke-linejoin','round');
      poly.classList.add('ghost-path');
      layer.appendChild(poly);
    },
    clonePosition(pos){
      if(!pos || typeof pos!=='object') return null;
      if(pos.kind==='track') return window.GameRules.Pos.track(pos.idx);
      if(pos.kind==='home') return window.GameRules.Pos.home(pos.idx);
      if(pos.kind==='base'){
        const slot=typeof pos.slot==='number'?pos.slot:0;
        return window.GameRules.Pos.base(slot);
      }
      if(pos.kind==='finished') return window.GameRules.Pos.finished();
      try{
        return window.structuredClone? structuredClone(pos):JSON.parse(JSON.stringify(pos));
      }catch(err){
        if(typeof pos.idx==='number') return {kind:pos.kind,idx:pos.idx};
        if(typeof pos.slot==='number') return {kind:pos.kind,slot:pos.slot};
        return {kind:pos.kind};
      }
    },
    clonePath(path){
      if(!Array.isArray(path)) return [];
      return path.map(p=>this.clonePosition(p)).filter(Boolean);
    },
    highlightMovables(){
      const g=this.$.gHL; g.innerHTML='';
      const host=this.$.movables; host.innerHTML='';
      const player=this.currentPlayer(); if(!player) return;

      const moves=this.state.legalMoves||[];
      const preserveLastPath = (!this.state.bonusSelecting && this.state.dice==null && (!moves || moves.length===0) && Array.isArray(this.state.lastMoveSummary?.path) && this.state.lastMoveSummary.path.length>0);
      if(preserveLastPath) this.previewLastMove(); else this.clearGhostPath();
      const defaultMove=moves[0]||null;
      const byPiece=new Map();
      moves.forEach(m=>{
        if(!byPiece.has(m.pieceIndex)) byPiece.set(m.pieceIndex,[]);
        byPiece.get(m.pieceIndex).push(m);
      });

      const pcs=this.state.pieces[player.id]||[];
      pcs.forEach((pc,idx)=>{
        const where=this.posToXY(player.color,pc.pos,idx,pc);
        if(!where) return;
        const hasMove=byPiece.has(idx);
        const ring=document.createElementNS('http://www.w3.org/2000/svg','circle');
        ring.setAttribute('cx',where.x);
        ring.setAttribute('cy',where.y);
        ring.setAttribute('r',hasMove?28:22);
        ring.setAttribute('fill',hasMove?'rgba(34,211,238,0.12)':'rgba(255,255,255,0.03)');
        ring.setAttribute('stroke',hasMove?'var(--accent)':'transparent');
        ring.setAttribute('stroke-width',hasMove?'2':'0');
        if(hasMove){
          ring.style.cursor='pointer';
          ring.addEventListener('click',()=>{
            const options=byPiece.get(idx)||[];
            if(options.length===1){
              this.applyMove(options[0],'mouse');
            }else if(options.length>1){
              const firstBtn=host.querySelector(`button[data-piece="${idx}"]`);
              if(firstBtn){
                firstBtn.focus();
                if(firstBtn.scrollIntoView){
                  firstBtn.scrollIntoView({block:'nearest'});
                }
              }
            }
          });
        }
        g.appendChild(ring);

        const txt=document.createElementNS('http://www.w3.org/2000/svg','text');
        txt.setAttribute('x',where.x);
        txt.setAttribute('y',where.y+4);
        txt.setAttribute('text-anchor','middle');
        txt.setAttribute('font-size','14');
        txt.setAttribute('fill','#e5e7eb');
        txt.textContent=String(idx+1);
        g.appendChild(txt);

        if(hasMove){
          const movesForPiece=byPiece.get(idx);
          const previewDefault=()=>{
            const first=movesForPiece?.[0];
            if(first) this.previewMove(first,player.color);
          };
          ring.addEventListener('pointerenter',previewDefault);
          ring.addEventListener('pointerleave',()=>{
            const fallback=movesForPiece?.[0]||defaultMove;
            if(fallback) this.previewMove(fallback,player.color); else this.clearGhostPath();
          });
          movesForPiece.forEach((mv,optIdx)=>{
            const btn=document.createElement('button');
            btn.type='button';
            btn.className='btn';
            btn.dataset.piece=String(idx);
            btn.dataset.option=String(optIdx);
            const prefix=movesForPiece.length>1?`${idx+1} 號棋（選項 ${optIdx+1}）`:`${idx+1} 號棋`;
            btn.textContent=`${prefix}：${this.describeMove(mv)}`;
            btn.addEventListener('click',()=>this.applyMove(mv,'mouse'));
            btn.addEventListener('pointerenter',()=>this.previewMove(mv,player.color));
            btn.addEventListener('pointerleave',()=>{
              const fallback=movesForPiece?.[0]||defaultMove;
              if(fallback) this.previewMove(fallback,player.color); else this.clearGhostPath();
            });
            btn.addEventListener('focus',()=>this.previewMove(mv,player.color));
            btn.addEventListener('blur',()=>{
              const fallback=movesForPiece?.[0]||defaultMove;
              if(fallback) this.previewMove(fallback,player.color); else this.clearGhostPath();
            });
            host.appendChild(btn);
          });
        }
      });

      if(host.childElementCount===0){
        const span=document.createElement('span');
        span.className='muted';
        span.textContent='沒有可移動棋子';
        host.appendChild(span);
        if(preserveLastPath) this.previewLastMove(); else this.clearGhostPath();
      }else if(moves.length>0){
        host.scrollTop=0;
        if(this.currentControlModeForTurn()==='keyboard' && !host.contains(document.activeElement)){
          const firstButton=host.querySelector('button');
          if(firstButton && typeof firstButton.focus==='function'){
            try{ firstButton.focus({preventScroll:true}); }
            catch(err){ firstButton.focus(); }
          }
        }
        this.previewMove(moves[0],player.color);
      }
    },
    describeMove(move){
      const parts=[];
      if(move.kind==='takeoff') parts.push('起飛');
      else if(typeof move.dice==='number') parts.push(`前進 ${move.dice}`);
      if(Array.isArray(move.stack) && move.stack.length>1) parts.push(`疊子×${move.stack.length}`);
      if(move.events){
        if(move.events.some(ev=>ev.type==='enter-home')) parts.push('入家路');
        if(move.events.some(ev=>ev.type==='jump')) parts.push('跳格');
        if(move.events.some(ev=>ev.type==='flight')) parts.push('飛行');
        if(move.events.some(ev=>ev.type==='finish')) parts.push('終點');
        if(move.events.some(ev=>ev.type==='portal')) parts.push('傳送');
        if(move.events.some(ev=>ev.type==='power-up')) parts.push('增益');
        if(move.events.some(ev=>ev.type==='trap')) parts.push('陷阱');
      }
      const capturedCount=Array.isArray(move.capture?.captured)?move.capture.captured.length:0;
      if(capturedCount>0) parts.push('吃子');
      return parts.join(' → ')||'移動';
    },
    posToXY(color,pos,pieceIndex=null,piece=null){
      if(pos.kind==='track') return this.geom.track[pos.idx];
      if(pos.kind==='home') return this.geom.home[color][pos.idx];
      if(pos.kind==='base'){
        const slots=this.geom.bases[color]||[];
        if(slots.length===0) return null;
        const slotFromPos=(typeof pos.slot==='number')?pos.slot:null;
        const idx=(slotFromPos!=null?slotFromPos:(pieceIndex!=null?pieceIndex:0));
        return slots[idx%slots.length];
      }
      if(pos.kind==='finished'){
        const slots=(this.geom.finishedSlots&&this.geom.finishedSlots[color])||[];
        if(slots.length===0) return null;
        const player=this.state.players.find(p=>p.color===color);
        const pid=player?.id;
        const assigned=pid!=null && this.state.finishedSlots?.[pid]? this.state.finishedSlots[pid][pieceIndex??0]:null;
        const pieceSlot=(piece && typeof piece.finishedSlot==='number')?piece.finishedSlot:null;
        const slotIdx=(typeof pos.slot==='number')?pos.slot:(typeof pos.index==='number')?pos.index:(pieceSlot!=null?pieceSlot:(assigned!=null?assigned:pieceIndex||0));
        const target=slots[(slotIdx||0)%slots.length]||slots[0];
        if(target) return {x:target.x,y:target.y};
      }
      return null;
    },
    redrawPieces(){
      const g=this.$.gPieces; g.innerHTML='';
      g.onclick=(e)=>{
        if(this.state.animating) return;
        if(!this.isInteractionPermitted('mouse')){ this.handleBlockedInteraction('mouse'); return; }
        const target=e.target.closest('[data-player][data-index]');
        if(!target) return;
        const pid=target.dataset.player;
        const idx=parseInt(target.dataset.index,10);
        if(pid!==this.state.turn||Number.isNaN(idx)) return;
        if(this.state.disabledColors && this.state.disabledColors[pid]) return;
        const mv=(this.state.legalMoves||[]).find(m=>m.pieceIndex===idx);
        if(mv) this.applyMove(mv,'mouse');
      };
      const active=[];
      const finished=[];
      for(const p of this.state.players){
        const pcs=this.state.pieces[p.id]||[];
        pcs.forEach((pc,idx)=>{
          const xy=this.posToXY(p.color,pc.pos,idx,pc);
          if(!xy) return;
          const wrapper=document.createElementNS(SVG_NS,'g');
          wrapper.dataset.player=p.id;
          wrapper.dataset.index=String(idx);
          wrapper.setAttribute('transform',`translate(${xy.x},${xy.y})`);
          wrapper.style.cursor='pointer';
          if(this.state.disabledColors && this.state.disabledColors[p.id]){
            wrapper.setAttribute('data-disabled','true');
            wrapper.setAttribute('aria-disabled','true');
          }
          const token=document.createElementNS(SVG_NS,'use');
          token.setAttributeNS('http://www.w3.org/1999/xlink','href','#plane-shape');
          token.setAttribute('href','#plane-shape');
          token.setAttribute('class',`plane-token plane-${p.color}`);
          token.setAttribute('data-player',p.id);
          token.setAttribute('data-index',String(idx));
          token.setAttribute('role','img');
          token.setAttribute('aria-label',`${p.name||p.id} 的飛機 ${idx+1}`);
          token.setAttribute('pointer-events','auto');
          token.setAttribute('x',-12);
          token.setAttribute('y',-12);
          token.setAttribute('width',24);
          token.setAttribute('height',24);
          wrapper.appendChild(token);
          const label=document.createElementNS(SVG_NS,'text');
          label.setAttribute('x',0);
          label.setAttribute('y',18);
          label.setAttribute('text-anchor','middle');
          label.setAttribute('dominant-baseline','middle');
          label.setAttribute('font-size','10');
          label.setAttribute('fill','var(--fg)');
          label.setAttribute('opacity','0.82');
          label.textContent=String(idx+1);
          label.dataset.player=p.id;
          label.dataset.index=String(idx);
          label.setAttribute('pointer-events','none');
          wrapper.appendChild(label);
          if(pc.pos?.kind==='finished'){
            wrapper.setAttribute('data-finished','true');
            const badge=document.createElementNS(SVG_NS,'use');
            badge.setAttributeNS('http://www.w3.org/1999/xlink','href','#finish-badge');
            badge.setAttribute('href','#finish-badge');
            badge.setAttribute('class','finish-badge');
            badge.setAttribute('transform','translate(14,-14) scale(0.8)');
            badge.setAttribute('pointer-events','none');
            wrapper.appendChild(badge);
            finished.push(wrapper);
          }else{
            active.push(wrapper);
          }
        });
      }
      active.forEach(node=>g.appendChild(node));
      finished.forEach(node=>g.appendChild(node));
    },

    applyMove(move,source='system'){
      if(!move) return;
      if(!this.isInteractionPermitted(source)){ this.handleBlockedInteraction(source); return; }
      const wasBonusMove=this.state.bonusSelecting===true;
      this.pushHistory();
      const pid=this.state.turn;
      const player=this.currentPlayer();
      let movingIndices=Array.isArray(move.stack)?move.stack.slice():[move.pieceIndex];
      if(!movingIndices.includes(move.pieceIndex)) movingIndices.push(move.pieceIndex);
      movingIndices=Array.from(new Set(movingIndices)).sort((a,b)=>a-b);
      const movingPieces=movingIndices.map(idx=>({idx,piece:this.state.pieces[pid]?.[idx]})).filter(entry=>entry.piece);
      const leadEntry=movingPieces.find(entry=>entry.idx===move.pieceIndex) || movingPieces[0];
      if(!leadEntry){ this.state.animating=false; return; }
      const piece=leadEntry.piece;
      const fromXY=this.posToXY(player.color,piece.pos,leadEntry.idx,piece);
      const toXY=this.posToXY(player.color,move.to,leadEntry.idx,piece)||fromXY;
      this.state.animating=true;
      const animCoords=this.resolveMovePath(player.color,move,leadEntry.idx,piece);
      if(Array.isArray(animCoords) && animCoords.length>0){
        const firstPoint=animCoords[0];
        if(!firstPoint || firstPoint.x!==fromXY.x || firstPoint.y!==fromXY.y){
          animCoords.unshift({x:fromXY.x,y:fromXY.y});
        }
        const lastPoint=animCoords[animCoords.length-1];
        if(!lastPoint || lastPoint.x!==toXY.x || lastPoint.y!==toXY.y){
          animCoords.push({x:toXY.x,y:toXY.y});
        }
      }
      this.animatePiece(player,fromXY,toXY,this.getAnimDuration(520),animCoords).then(async()=>{
        const capturedInfos=[];
        if(move.capture && move.capture.captured && move.capture.captured.length>0 && move.to.kind==='track'){
          for(const opp of this.state.players){
            if(opp.id===pid) continue;
            const oppPieces=this.state.pieces[opp.id]||[];
            oppPieces.forEach((pc,idx)=>{
              if(pc.pos.kind==='track' && pc.pos.idx===move.to.idx){
                capturedInfos.push({opp,pieceIndex:idx});
              }
            });
          }
        }

        for(const info of capturedInfos){
          const from=this.geom.track[move.to.idx];
          const capturedPiece=this.state.pieces[info.opp.id]?.[info.pieceIndex];
          const slotIndex=typeof capturedPiece?.baseSlot==='number'?capturedPiece.baseSlot:info.pieceIndex;
          const targetBase=this.posToXY(info.opp.color, window.GameRules.Pos.base(slotIndex), slotIndex,capturedPiece);
          if(targetBase){
            await this.animatePiece({color:info.opp.color}, from, targetBase, this.getAnimDuration(420));
          }
        }

        const toPosition=(target,slot)=>{
          if(!target) return null;
          if(target.kind==='track') return window.GameRules.Pos.track(target.idx);
          if(target.kind==='home') return window.GameRules.Pos.home(target.idx);
          if(target.kind==='finished') return window.GameRules.Pos.finished();
          if(target.kind==='base') return window.GameRules.Pos.base(slot);
          try{ return window.structuredClone? window.structuredClone(target):JSON.parse(JSON.stringify(target)); }catch(e){ return target; }
        };

        if(!this.state.finishedSlots) this.state.finishedSlots={};
        if(!this.state.finishedSlots[pid]) this.state.finishedSlots[pid]={};
        const finishedMap=this.state.finishedSlots[pid];
        movingPieces.forEach(({idx,piece:pc})=>{
          const slotIndex=typeof pc.baseSlot==='number'?pc.baseSlot:idx;
          pc.baseSlot=slotIndex;
          if(move.to.kind==='base'){
            pc.pos=window.GameRules.Pos.base(slotIndex);
            if(finishedMap) delete finishedMap[idx];
            delete pc.finishedSlot;
          }else{
            pc.pos=toPosition(move.to,slotIndex);
            if(pc.pos?.kind==='finished'){
              if(typeof finishedMap[idx]!=='number'){
                const used=new Set(Object.values(finishedMap));
                let nextSlot=0;
                while(used.has(nextSlot) && nextSlot<4){ nextSlot+=1; }
                finishedMap[idx]=nextSlot;
              }
              pc.finishedSlot=finishedMap[idx];
            }else{
              if(finishedMap) delete finishedMap[idx];
              delete pc.finishedSlot;
            }
          }
        });

        if(capturedInfos.length>0){
          for(const info of capturedInfos){
            const capturedPiece=this.state.pieces[info.opp.id]?.[info.pieceIndex];
            if(!capturedPiece) continue;
            const slot=typeof capturedPiece.baseSlot==='number'?capturedPiece.baseSlot:info.pieceIndex;
            capturedPiece.baseSlot=slot;
            capturedPiece.pos=window.GameRules.Pos.base(slot);
            if(this.state.finishedSlots?.[info.opp.id]) delete this.state.finishedSlots[info.opp.id][info.pieceIndex];
            delete capturedPiece.finishedSlot;
          }
          this.log(`${player.name} 吃子！把對手送回基地`);
        }

        if(movingPieces.length>1){
          this.log(`${player.name} 疊子合體移動（${movingPieces.length} 枚）`);
        }

        const effectsOutcome=this.applySpecialEffects({player,move,leadIndex:leadEntry.idx});
        const extraTurnFromEvent=!!effectsOutcome.extraTurn;
        let pendingBonusRequest=effectsOutcome.pendingBonus;

        this.state.finishOrder=this.state.finishOrder||[];
        this.state.disabledColors=this.state.disabledColors||{};
        const allPieces=[];
        this.state.players.forEach(pl=>{
          (this.state.pieces[pl.id]||[]).forEach(pc=>{
            allPieces.push({playerId:pl.id,pos:pc?.pos});
          });
        });
        const perPlayerPieces=(window.GameRules?.BOARD?.bases?.perPlayer)||4;
        const finishedCount=allPieces.reduce((acc,entry)=>{
          return acc + ((entry.playerId===pid && entry.pos && entry.pos.kind==='finished')?1:0);
        },0);
        if(finishedCount>=perPlayerPieces && !this.state.finishOrder.includes(pid)){
          this.state.finishOrder.push(pid);
          if(!this.state.winner) this.state.winner=pid;
          this.state.disabledColors[pid]=true;
          if(typeof window!=='undefined' && typeof window.showWinnerEffect==='function'){
            try{ window.showWinnerEffect(pid); }catch(err){ console.warn('showWinnerEffect failed',err); }
          }
          if(typeof window!=='undefined' && typeof window.showWinnerModal==='function'){
            try{ window.showWinnerModal(pid,{finishOrder:this.state.finishOrder}); }catch(err){ /* noop */ }
          }
          const emitter=(typeof window!=='undefined' && typeof window.emit==='function')?window.emit:null;
          if(emitter) emitter('playerFinished',{playerId:pid,finishOrder:this.state.finishOrder});
        }

        this.redrawPieces();
        this.$.gHL.innerHTML='';
        this.pulseAt(toXY.x,toXY.y,`var(--${player.color})`);
        if(move.to.kind==='track'){
          const faces=this.computeThreatFaces(move.to.idx);
          this.showThreatBadge(toXY.x,toXY.y,faces);
        }else{
          this.showThreatBadge(toXY.x,toXY.y,[]);
        }

        this.state.animating=false;

        const colorName=this.currentPlayer()?.color||player.color;
        const baseSummaryPath=this.clonePath(move.path||[]);
        const fromPos=this.clonePosition(move.from);
        const toPos=this.clonePosition(move.to);
        if(fromPos && (baseSummaryPath.length===0 || !window.GameRules.Pos.isEqual(baseSummaryPath[0],fromPos))){
          baseSummaryPath.unshift(fromPos);
        }
        if(toPos && baseSummaryPath.length===0){
          baseSummaryPath.push(toPos);
        }
        if(toPos && baseSummaryPath.length>0 && !window.GameRules.Pos.isEqual(baseSummaryPath[baseSummaryPath.length-1],toPos)){
          baseSummaryPath.push(toPos);
        }
        const summaryCaptured=Array.isArray(move.capture?.captured)?move.capture.captured.map(info=>Object.assign({},info)) : [];
        this.state.lastMoveSummary={
          player:{id:player.id,name:player.name,color:colorName},
          dice:move.dice,
          description:this.describeMove(move),
          captured:summaryCaptured,
          path:baseSummaryPath,
          pieceIndex:move.pieceIndex,
          stackSize:Array.isArray(move.stack)?move.stack.length:1,
          kind:move.kind
        };
        this.renderLastMove();

        if(pendingBonusRequest){
          this.state.pendingBonus=pendingBonusRequest;
          this.state.bonusSelecting=true;
          this.state.dice=pendingBonusRequest.dice;
          this.$.diceOut.textContent=String(pendingBonusRequest.dice);
          this.state.legalMoves=[];
          this.refreshLegalMoves();
          if((this.state.legalMoves||[]).length===0){
            this.log('增益移動未能觸發');
            this.state.bonusSelecting=false;
            this.state.pendingBonus=null;
            this.state.dice=null;
            this.$.diceOut.textContent='–';
          }else{
            this.renderHints();
            this.updateTurnUI();
            this.updateTurnPrompt(true);
            this.saveGame();
            const needsChoice=(pendingBonusRequest.autoResolve===false) || (this.state.legalMoves.length>1);
            if(needsChoice) this.maybeAutoPlayIfAI();
            if(pendingBonusRequest.autoResolve!==false && this.state.legalMoves.length===1){
              const autoMove=this.state.legalMoves[0];
              requestAnimationFrame(()=>this.applyMove(autoMove,'system'));
            }
            return;
          }
        }

        if(wasBonusMove){
          this.state.bonusSelecting=false;
        }
        this.state.pendingBonus=null;
        this.state.dice=null;
        this.$.diceOut.textContent='–';
        this.state.legalMoves=[];
        this.previewLastMove();

        const rolledValue=move.dice;
        const playerFinished=this.state.finishOrder?.includes(pid) || !!this.state.disabledColors?.[pid];
        const again=(!wasBonusMove && !playerFinished && (((rolledValue===6)&&this.state.rules?.extraTurnOnSix) || extraTurnFromEvent));
        this.renderHints();
        if(!again){
          this.advanceTurn();
        }else{
          this.state.legalMoves=[];
          this.clearTurnTimer();
          this.beginTurnTimer();
          this.saveGame();
          this.updateTurnUI();
          this.updateTurnPrompt(true);
          this.maybeAutoPlayIfAI();
        }
      });
    },
    applySpecialEffects({player,move,leadIndex}){
      const outcome={extraTurn:false,pendingBonus:null};
      const events=Array.isArray(move?.events)?move.events:[];
      events.forEach(ev=>{
        if(ev.type==='enter-home') this.log(`${player.name} 進入家路`);
        else if(ev.type==='jump') this.log(`${player.name} 觸發跳格 (+${this.state.rules?.ownColorJump?.steps||0})`);
        else if(ev.type==='flight') this.log(`${player.name} 走飛線`);
        else if(ev.type==='finish') this.log(`${player.name} 抵達終點！`);
        else if(ev.type==='portal'){
          const label=ev.label?` ${ev.label}`:'';
          this.log(`${player.name} 穿越傳送門${label}`);
          this.showToast(`🌀 傳送門${label||''}！`,1200);
        }
        else if(ev.type==='power-up'){
          if(ev.effect==='extra-roll'){
            this.log(`${player.name} 拿到增擲機會！`);
            this.showToast('🎲 加擲機會！',1400);
          }else if(ev.effect==='advance-2'){
            this.log(`${player.name} 動力提升，準備再飛 2 格`);
          }else if(ev.effect==='command-other'){
            this.log(`${player.name} 獲得指揮權，可讓另一架棋子前進 1 格`);
          }
        }
        else if(ev.type==='trap'){
          if(ev.effect==='skip-turn'){
            this.log(`${player.name} 遭遇亂流，下一回合將停飛`);
            this.showToast('⚠️ 亂流！下回合停飛',1600);
          }
        }
      });
      const effects=Array.isArray(move?.effects)?move.effects:[];
      effects.forEach(effect=>{
        if(effect.type==='power-up'){
          if(effect.effect==='extra-roll'){
            outcome.extraTurn=true;
          }else if(effect.effect==='advance-2'){
            if(!outcome.pendingBonus){ outcome.pendingBonus={dice:2,restrict:'same',pieceIndex:leadIndex??move.pieceIndex,description:'向前再飛 2 格',source:'power-up',autoResolve:true}; }
          }else if(effect.effect==='command-other'){
            outcome.pendingBonus={dice:1,restrict:'others',pieceIndex:leadIndex??move.pieceIndex,description:'指揮另一架飛機前進 1 格',source:'power-up',autoResolve:false};
          }
        }else if(effect.type==='trap' && effect.effect==='skip-turn'){
          if(!this.state.skipTurns) this.state.skipTurns={};
          const currentSkip=Math.max(0,this.state.skipTurns[player.id]||0);
          this.state.skipTurns[player.id]=currentSkip+1;
        }
      });
      return outcome;
    },
    advanceTurn(){
      const playersList=this.state.players||[];
      if(!Array.isArray(playersList) || playersList.length===0) return null;
      if(this._noMoveTimer){ clearTimeout(this._noMoveTimer); this._noMoveTimer=null; }
      const prevId=this.state.turn;
      if(prevId!=null && this.state.consecutiveSixes){ this.state.consecutiveSixes[prevId]=0; }
      const total=playersList.length;
      this.state.finishOrder=this.state.finishOrder||[];
      this.state.disabledColors=this.state.disabledColors||{};
      const currentIdx=playersList.findIndex(p=>p.id===prevId);
      let idx=(currentIdx<0?0:(currentIdx+1)%total);
      let attempts=0;
      let target=null;
      while(attempts<total){
        const candidate=playersList[idx];
        if(!candidate){ attempts++; idx=(idx+1)%total; continue; }
        const candidateId=candidate.id;
        const skipCount=Math.max(0,this.state.skipTurns?.[candidateId]||0);
        if(skipCount>0){
          this.state.skipTurns[candidateId]=skipCount-1;
          this.log(`${candidate.name} 被亂流困住，跳過此回合`);
          this.showToast(`${candidate.name} 暫停一回合`,1200);
          attempts++; idx=(idx+1)%total; continue;
        }
        const isFinished=this.state.finishOrder.includes(candidateId) || !!this.state.disabledColors[candidateId];
        if(isFinished){ attempts++; idx=(idx+1)%total; continue; }
        target=candidate;
        break;
      }
      if(!target){
        this.state.turn=null;
        this.state.dice=null;
        this.state.legalMoves=[];
        this.$.diceOut.textContent='–';
        this.renderLastMove();
        this.previewLastMove();
        this.clearTurnTimer();
        this.updateTurnUI();
        this.saveGame();
        this.updateTurnPrompt(true);
        return null;
      }
      if(this.state.consecutiveSixes){ this.state.consecutiveSixes[target.id]=0; }
      this.state.turn=target.id;
      this.state.dice=null;
      this.state.legalMoves=[];
      this.$.diceOut.textContent='–';
      this.renderLastMove();
      this.previewLastMove();
      this.clearTurnTimer();
      this.updateTurnUI();
      this.saveGame();
      this.updateTurnPrompt(true);
      this.maybeAutoPlayIfAI();
      return target;
    },
    onKey(e){
      if(this.state.view!=='game' || this.state.animating) return;
      if(e.key==='u'||e.key==='U'){ this.undo(); return; }
      if(!this.isInteractionPermitted('keyboard')){ this.handleBlockedInteraction('keyboard'); return; }
      const mode=this.state.settings.keyboardMode||'shared';
      const pIdx=this.state.players.findIndex(p=>p.id===this.state.turn);
      const pieces=this.state.pieces[this.state.turn]||[];
      const pieceCount=pieces.length;
      if(e.code==='Space' || e.key===' ' || e.key==='Spacebar'){
        e.preventDefault();
        this.rollDice('keyboard');
        return;
      }
      let selIndex=null;
      const keyPool=(()=>{
        if(mode==='dual'){
          if(pIdx===0) return ['1','2','3','4'];
          if(pIdx===1) return ['7','8','9','0'];
          return ['1','2','3','4','5','6','7','8','9'];
        }
        return ['1','2','3','4','5','6','7','8','9'];
      })();
      const idx=keyPool.indexOf(e.key);
      if(idx>-1 && idx<pieceCount) selIndex=idx;
      if(selIndex!=null){
        const movesForPiece=(this.state.legalMoves||[]).filter(m=>m.pieceIndex===selIndex);
        if(movesForPiece.length===1){
          this.applyMove(movesForPiece[0],'keyboard');
        }else if(movesForPiece.length>1){
          e.preventDefault();
          const firstMove=movesForPiece[0];
          const host=this.$?.movables;
          if(host){
            const firstBtn=host.querySelector(`button[data-piece="${selIndex}"]`);
            if(firstBtn){
              firstBtn.focus();
              if(firstBtn.scrollIntoView){
                try{ firstBtn.scrollIntoView({block:'nearest'}); }catch(err){ firstBtn.scrollIntoView(); }
              }
            }
          }
          if(firstMove){
            const player=this.currentPlayer();
            this.previewMove(firstMove,player?.color||null);
          }
          this.showToast('此棋有多個選項，選擇後按 Enter/Space 確認',1600);
        }
      }
    },

    // --------- Persistence / Undo ---------
    snapshot(){
      return JSON.parse(JSON.stringify({
        players:this.state.players,
        pieces:this.state.pieces,
        turn:this.state.turn,
        rules:this.state.rules,
        dice:this.state.dice,
        consecutiveSixes:this.state.consecutiveSixes,
        skipTurns:this.state.skipTurns,
        bonusSelecting:this.state.bonusSelecting,
        pendingBonus:this.state.pendingBonus,
        settings:this.state.settings,
        lastMoveSummary:this.state.lastMoveSummary,
        finishOrder:this.state.finishOrder,
        winner:this.state.winner,
        disabledColors:this.state.disabledColors,
        finishedSlots:this.state.finishedSlots
      }));
    },
    saveGame(){
      if(!Array.isArray(this.state.players) || this.state.players.length===0) return;
      const payload={version:SAVE_VERSION, board:window.GameRules?.BOARD?.boardSpecVersion, state:this.snapshot()};
      try{
        localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
        if(this.$?.btnContinue) this.$.btnContinue.disabled=false;
      }catch(e){}
    },
    loadGame(){
      try{
        const raw=localStorage.getItem(SAVE_KEY);
        if(!raw) return null;
        const parsed=JSON.parse(raw);
        if(parsed && typeof parsed==='object' && parsed.state){ return parsed; }
        return {version:'legacy', state:parsed};
      }catch(e){ return null; }
    },
    clearSave(){
      try{ localStorage.removeItem(SAVE_KEY); if(this.$?.btnContinue) this.$.btnContinue.disabled=true; }catch(e){}
      this.updateBoardOverlay();
    },
    continueFromSave(data=null){
      const payload=data||this.loadGame();
      if(!payload){ this.log('冇儲存對局'); return; }
      const snapshot=payload.state||payload;
      this.state.settings=Object.assign({keyboardMode:'shared',theme:'dark'}, snapshot.settings||{});
      this.applyTheme();
      if(this.$.kbMode) this.$.kbMode.value=this.state.settings.keyboardMode||'shared';
      this.state.players=snapshot.players||[];
      this.normalizePlayerControls();
      this.state.pieces=snapshot.pieces||{};
      this.state.turn=snapshot.turn||null;
      const loadedRules=snapshot.rules? this.cloneDefaultRules(snapshot.rules) : this.cloneDefaultRules();
      this.state.rules=loadedRules;
      this.applyBoardDefaultsToRules();
      this.state.dice=snapshot.dice??null;
      this.state.consecutiveSixes=snapshot.consecutiveSixes||{};
      this.state.skipTurns=snapshot.skipTurns||{};
      this.state.players.forEach(p=>{ if(this.state.skipTurns[p.id]==null) this.state.skipTurns[p.id]=0; });
      this.state.bonusSelecting=!!snapshot.bonusSelecting;
      this.state.pendingBonus=snapshot.pendingBonus||null;
      this.state.history=[];
      this.state.lastMoveSummary=snapshot.lastMoveSummary||null;
      this.state.finishOrder=Array.isArray(snapshot.finishOrder)?snapshot.finishOrder.slice():[];
      this.state.winner=snapshot.winner||null;
      this.state.disabledColors=Object.assign({},snapshot.disabledColors||{});
      this.state.finishedSlots=JSON.parse(JSON.stringify(snapshot.finishedSlots||{}));
      this.normalizePieces();
      this.updateControlAssignments();
      this.renderLastMove();
      this.toGame();
      this.bootstrapBoard();
      this.redrawPieces();
      this.clearTurnTimer();
      this.beginTurnTimer();
      if(this.state.bonusSelecting && this.state.dice!=null){
        this.refreshLegalMoves();
      }else{
        this.state.legalMoves=[];
        this.highlightMovables();
      }
      this.renderHints();
      this.updateTurnUI();
      this.updateTurnPrompt(true);
      this.log('已載入上局');
      const toastMsg=this._pendingToast||'已載入上局';
      if(toastMsg) this.showToast(toastMsg);
      this._pendingToast=null;
      if(this.$?.btnContinue) this.$.btnContinue.disabled=false;
      this.updateSpecialsLegend();
      this.updateBoardOverlay();
      this.maybeAutoPlayIfAI();
    },
    pushHistory(){
      if(!this.state.rules?.undoEnabled) return;
      const snap=this.snapshot();
      if(!Array.isArray(this.state.history)) this.state.history=[];
      this.state.history.push(snap);
      if(this.state.history.length>20) this.state.history.shift();
    },
    undo(){
      if(!this.state.rules?.undoEnabled){ this.log('未啟用 Undo'); return; }
      const snap=this.state.history?.pop?.();
      if(!snap){ this.log('無可 Undo 嘅步'); return; }
      this.state.players=snap.players; this.state.pieces=snap.pieces; this.state.turn=snap.turn; this.state.rules=snap.rules;
      this.normalizePlayerControls();
      this.updateControlAssignments();
      this.state.dice=snap.dice??null; this.state.consecutiveSixes=snap.consecutiveSixes||{};
      this.state.skipTurns=snap.skipTurns||{};
      this.state.finishOrder=Array.isArray(snap.finishOrder)?snap.finishOrder.slice():[];
      this.state.winner=snap.winner||null;
      this.state.disabledColors=Object.assign({},snap.disabledColors||{});
      this.state.finishedSlots=JSON.parse(JSON.stringify(snap.finishedSlots||{}));
      this.state.settings=Object.assign({keyboardMode:'shared',theme:'dark'}, snap.settings||{});
      this.applyTheme();
      if(this.$.kbMode) this.$.kbMode.value=this.state.settings.keyboardMode||'shared';
      this.state.lastMoveSummary=snap.lastMoveSummary||null;
      this.normalizePieces();
      this.$.diceOut.textContent=this.state.dice==null?'–':String(this.state.dice);
      this.clearTurnTimer();
      this.beginTurnTimer();
      this.redrawPieces(); this.$.gHL.innerHTML='';
      this.renderLastMove();
      this.updateTurnUI();
      this.saveGame();
      this.log('已撤銷一步');
      this.updateSpecialsLegend();
      this.maybeAutoPlayIfAI();
    },

    // --------- AI ---------
    isAI(player){ return (player.type||'human')==='ai'; },
    chooseAIMove(){
      const player=this.currentPlayer();
      const moves=this.state.legalMoves||[];
      if(moves.length===0) return null;
      const rules=this.state.rules||window.GameRules.DEFAULT_RULES;
      const distToFinish=(color,pos)=>{
        const BOARD=window.GameRules.BOARD;
        const L=BOARD.track.length;
        const entry=BOARD.homeLane.entryIndex[color];
        const homeLen=BOARD.homeLane.length;
        if(pos.kind==='finished') return 0;
        if(pos.kind==='home') return (homeLen-1-pos.idx);
        if(pos.kind==='track'){
          const dToEntry=((entry-pos.idx)%L+L)%L;
          const enterHomeStep=(dToEntry===0)?1:0;
          return dToEntry+enterHomeStep+(homeLen-1);
        }
        if(pos.kind==='base'){
          const start=BOARD.track.startIndex[color];
          const startDist=distToFinish(color,window.GameRules.Pos.track(start));
          return startDist+1; // include the takeoff step from base to the start tile
        }
        return 0;
      };
      const isSafeTile=(color,idx)=>{
        const start=window.GameRules.BOARD.track.startIndex[color];
        if(rules.safeTiles?.start && idx===start) return true;
        return (rules.safeTiles?.list||[]).includes(idx);
      };
      const captureRiskProb=(color,idx)=>{
        if(isSafeTile(color,idx)) return 0;
        let hits=0;
        const L=window.GameRules.BOARD.track.length;
        for(const opp of this.state.players){
          if(opp.id===player.id) continue;
          const oppPieces=this.state.pieces[opp.id]||[];
          for(const pc of oppPieces){
            if(pc.pos.kind!=='track') continue;
            const d=((idx-pc.pos.idx)%L+L)%L;
            if(d>=1&&d<=6) hits+=1;
          }
        }
        return Math.min(1,hits/6);
      };
      const myPieces=this.state.pieces[player.id]||[];
      const scored=moves.map(m=>{
        const beforePos=myPieces[m.pieceIndex]?.pos||window.GameRules.Pos.base();
        const before=distToFinish(player.color,beforePos);
        const after=distToFinish(player.color,m.to);
        const progress=Math.max(0,before-after);
        // Weight raw progress so that large advances matter, but a single-step takeoff
        // no longer eclipses finish/capture bonuses now that base distance is normalized.
        const PROGRESS_WEIGHT=60;
        let score=progress*PROGRESS_WEIGHT;
        const cap=(m.capture&&(m.capture.captured||[]).length)||0;
        score+=cap*1000;
        if(m.to.kind==='finished') score+=900;
        if((m.events||[]).some(e=>e.type==='enter-home')) score+=400;
        if((m.events||[]).some(e=>e.type==='jump')) score+=140;
        if((m.events||[]).some(e=>e.type==='flight')) score+=90;
        if(m.kind==='takeoff') score+=80;
        if(m.to.kind==='track' && isSafeTile(player.color,m.to.idx)) score+=60;
        const specials=[...(m.events||[]),...(m.effects||[])];
        if(specials.some(e=>e?.type==='trap')) score-=500;
        if(specials.some(e=>e?.type==='power-up')) score+=150;
        if(m.to.kind==='track'){
          const prob=captureRiskProb(player.color,m.to.idx);
          score-=prob*700;
        }
        return {move:m,score,before,after};
      });
      scored.sort((a,b)=> b.score!==a.score? b.score-a.score : ((a.before-a.after)!==(b.before-b.after)? (b.before-b.after)-(a.before-a.after) : (((b.move.capture?.captured||[]).length)-((a.move.capture?.captured||[]).length))));
      return scored[0].move;
    },
    maybeAutoPlayIfAI(){
      if(this.state.view!=='game') return;
      const player=this.currentPlayer();
      if(!this.isAI(player)) return;
      setTimeout(()=>{
        if(this.state.animating) return this.maybeAutoPlayIfAI();
        const current=this.currentPlayer();
        if(!this.isAI(current)) return;
        if(current.id!==player.id){
          this.maybeAutoPlayIfAI();
          return;
        }
        if(this.state.dice==null){
          this.rollDice('system');
          return;
        }
        const mv=this.chooseAIMove();
        if(mv){
          this.applyMove(mv,'system');
        }else{
          this.log(`${current.name} 無步可走`);
          this.handleNoMoves(current);
        }
      },300);
    },

    // --------- Anim / Effects ---------
    animatePiece(player,from,to,duration=480,path=null){ duration=this.getAnimDuration(duration); return new Promise(resolve=>{ const g=this.$.gHL; if(!g){ resolve(); return; } const NS='http://www.w3.org/2000/svg'; const ghost=document.createElementNS(NS,'circle'); ghost.setAttribute('cx',from.x); ghost.setAttribute('cy',from.y); ghost.setAttribute('r',18); ghost.setAttribute('fill',`var(--${player.color})`); ghost.setAttribute('stroke','#0b0f14'); ghost.setAttribute('stroke-width','3'); g.appendChild(ghost); const coords=Array.isArray(path)&&path.length>1?path.map(pt=>({x:pt.x,y:pt.y})):[{x:from.x,y:from.y},{x:to.x,y:to.y}]; if(coords.length<2){ coords.push({x:to.x,y:to.y}); } const segments=[]; for(let i=0;i<coords.length-1;i++){ const start=coords[i]; const end=coords[i+1]; const len=Math.hypot(end.x-start.x,end.y-start.y); segments.push({start,end,len:len||0.0001}); } if(segments.length===0){ if(ghost.parentNode) ghost.parentNode.removeChild(ghost); resolve(); return; } const totalLen=segments.reduce((acc,seg)=>acc+seg.len,0)||1; const ease=t=>1-Math.pow(1-t,3); const t0=performance.now(); const step=(now)=>{ const raw=Math.min(1,(now-t0)/duration); const eased=ease(raw); const targetDist=totalLen*eased; let traversed=0; let segmentIndex=0; while(segmentIndex<segments.length-1 && traversed+segments[segmentIndex].len<targetDist){ traversed+=segments[segmentIndex].len; segmentIndex++; } const segment=segments[segmentIndex]; const segLen=segment.len||1; const local=(segLen===0)?1:Math.min(1,(targetDist-traversed)/segLen); const x=segment.start.x+(segment.end.x-segment.start.x)*local; const y=segment.start.y+(segment.end.y-segment.start.y)*local; ghost.setAttribute('cx',x); ghost.setAttribute('cy',y); if(raw<1){ requestAnimationFrame(step); }else{ if(ghost.parentNode) ghost.parentNode.removeChild(ghost); resolve(); } }; requestAnimationFrame(step); }); },
    pulseAt(x,y,color){ const g=this.$.gHL; if(!g) return; const NS='http://www.w3.org/2000/svg'; const ring=document.createElementNS(NS,'circle'); ring.setAttribute('cx',x); ring.setAttribute('cy',y); ring.setAttribute('r','8'); ring.setAttribute('fill','none'); ring.setAttribute('stroke',color); ring.setAttribute('stroke-width','3'); ring.setAttribute('opacity','0.9'); g.appendChild(ring); let r=8; const id=setInterval(()=>{ r+=4; ring.setAttribute('r',r); const op=parseFloat(ring.getAttribute('opacity')); ring.setAttribute('opacity',String(Math.max(0,op-0.12))); if(r>36){ clearInterval(id); if(ring.parentNode) ring.parentNode.removeChild(ring);} },16); },
    computeThreatFaces(targetIdx){ const L=window.GameRules.BOARD.track.length; const me=this.currentPlayer(); const faces=new Set(); for(const opp of this.state.players){ if(opp.id===me.id) continue; const oppPieces=this.state.pieces[opp.id]||[]; for(const pc of oppPieces){ if(pc.pos.kind!=='track') continue; const d=((targetIdx-pc.pos.idx)%L+L)%L; if(d>=1&&d<=6) faces.add(d); } } return Array.from(faces).sort((a,b)=>a-b); },
    showThreatBadge(x,y,faces){ const g=this.$.gHL; g.querySelectorAll('.threat-badge').forEach(n=>n.remove()); if(!faces||faces.length===0) return; const NS='http://www.w3.org/2000/svg'; const bx=x+26,by=y-26; const badge=document.createElementNS(NS,'g'); badge.setAttribute('class','threat-badge'); const rect=document.createElementNS(NS,'rect'); const label=faces.join('/'); const padding=6; const width=Math.max(24,label.length*7+padding*2); rect.setAttribute('x',bx-width/2); rect.setAttribute('y',by-10); rect.setAttribute('width',width); rect.setAttribute('height',20); rect.setAttribute('rx',6); rect.setAttribute('fill','#ef4444'); rect.setAttribute('stroke','#000'); rect.setAttribute('stroke-width','2'); const txt=document.createElementNS(NS,'text'); txt.setAttribute('x',bx); txt.setAttribute('y',by+5); txt.setAttribute('text-anchor','middle'); txt.setAttribute('font-size','12'); txt.setAttribute('fill','#0b0f14'); txt.textContent=label; badge.appendChild(rect); badge.appendChild(txt); g.appendChild(badge); }
  };
  window.App = App; window.addEventListener('DOMContentLoaded',()=>App.init());
  // ============================= End App ===============================
  </script>
</body>
</html>
