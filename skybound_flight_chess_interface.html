<!doctype html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Skybound Flight Chess Interface</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0a0a0a;--fg:#e5e7eb;--muted:#9ca3af;--card:#0b0f14;--tile-grid:#374151;
      --red:#ff5c8a;--blue:#33ccff;--yellow:#ffd633;--green:#66ffb2;
      --red-ghost:#7f2c42;--blue-ghost:#1b4a5a;--yellow-ghost:#7a6a1a;--green-ghost:#2a5f49;
      --accent:#22d3ee;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";background:var(--bg);color:var(--fg)}
    .container{max-width:1200px;margin:0 auto;padding:16px}
    .app-bar{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:14px;border:1px solid #1f2937;background:#111827;color:#e5e7eb;cursor:pointer}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .grid{display:grid;gap:16px}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:16px;padding:16px}
    .board-area{display:grid;grid-template-columns:1fr;gap:16px}
    @media(min-width:960px){.board-area{grid-template-columns:1fr 320px}}
    .section-title{font-weight:800;margin:0 0 8px}
    .muted{color:var(--muted)}
    .list{display:flex;flex-wrap:wrap;gap:8px}
    .pill{border:1px solid #334155;border-radius:999px;padding:6px 10px}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
    .board-wrap{aspect-ratio:1/1;background:#0a0a0a;border-radius:16px;border:1px solid #1f2937;display:grid;place-items:center}
    svg.board{width:100%;height:100%;max-width:min(80vh,880px)}
    .log{height:200px;overflow:auto;border-radius:12px;background:#0b0f14;border:1px solid #1f2937;padding:8px}
    fieldset{border:1px solid #334155;border-radius:12px;padding:12px}
    legend{padding:0 8px}
    label{display:flex;align-items:center;gap:8px}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    input[type="text"], select{background:#0b1220;color:#e5e7eb;border:1px solid #334155;border-radius:10px;padding:8px}
    #turn-banner{position:sticky;top:16px;z-index:20;display:block;padding:10px 18px;border-radius:999px;background:rgba(34,211,238,0.16);color:#0f172a;font-weight:600;border:1px solid rgba(34,211,238,0.35);box-shadow:0 8px 18px rgba(15,23,42,0.35);max-width:fit-content;margin:0 auto 12px auto;opacity:0;transform:translateY(-6px);transition:opacity .18s ease,transform .22s ease}
    #turn-banner[data-show="true"]{opacity:1;transform:translateY(0)}
    #hint-card{margin-top:12px;padding:12px;border-radius:14px;background:rgba(15,23,42,0.68);border:1px solid #1f2937;display:flex;flex-direction:column;gap:8px}
    #hint-card h3{margin:0;font-size:.95rem;font-weight:600;color:#f1f5f9}
    #hint-card ul{margin:0;padding-left:18px;display:flex;flex-direction:column;gap:4px;color:#cbd5f5;font-size:.9rem}
    #hint-card .hint-meta{font-size:.8rem;color:var(--muted)}
    #toast-host{pointer-events:none;min-height:26px}
    .toast-message{display:inline-flex;align-items:center;gap:6px;padding:6px 12px;margin-top:6px;border-radius:999px;background:rgba(34,211,238,0.18);color:#38bdf8;border:1px solid rgba(56,189,248,0.4);box-shadow:0 4px 14px rgba(8,47,73,0.3);opacity:0;transform:translateY(-4px);transition:opacity .18s ease,transform .22s ease}
    .toast-message[data-show="true"]{opacity:1;transform:translateY(0)}
    @media(prefers-reduced-motion:reduce){
      #turn-banner{transition:opacity .1s ease;transform:none}
      .toast-message{transition:opacity .1s ease;transform:none}
    }
  </style>
</head>
<body>
  <header class="container app-bar" role="banner">
    <div class="row" aria-label="brand">
      <strong>✈️ 飛行棋</strong>
      <span class="muted">MVP</span>
    </div>
    <nav aria-label="global">
      <button class="btn" id="btn-lobby">返回大廳</button>
      <button class="btn" id="btn-settings" aria-haspopup="dialog" aria-controls="dialog-settings">設定</button>
      <button class="btn" id="btn-about" aria-haspopup="dialog" aria-controls="dialog-about">說明</button>
    </nav>
  </header>

  <main class="container" id="app" role="main">
    <div id="turn-banner" role="status" aria-live="assertive" hidden></div>
    <!-- 1) Lobby / Setup -->
    <section id="view-lobby" class="grid" aria-labelledby="title-lobby">
      <h1 id="title-lobby" class="section-title">大廳／開局設定</h1>
      <div class="card">
        <form id="form-setup" aria-describedby="setup-help">
          <p id="setup-help" class="muted">選擇玩家、顏色、規則。按「開始遊戲」。</p>

          <fieldset>
            <legend>玩家</legend>
            <div class="row">
              <label>人數
                <select name="playerCount" id="playerCount" aria-label="玩家人數">
                  <option value="2" selected>2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                </select>
              </label>
            </div>
            <div id="player-list" class="grid" style="grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px">
              <!-- Player cards generated by JS -->
            </div>
          </fieldset>

          <fieldset>
            <legend>規則預設</legend>
            <div class="row">
              <label><input type="radio" name="preset" value="classic" checked> 經典</label>
              <label><input type="radio" name="preset" value="fast"> 速戰</label>
              <label><input type="radio" name="preset" value="custom"> 自訂</label>
            </div>
            <details id="rules-advanced">
              <summary>自訂規則（展開）</summary>
              <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;margin-top:8px">
                <fieldset>
                  <legend>起飛</legend>
                  <label><input type="radio" name="takeoff" value="six" checked> 擲 6 才起飛</label>
                  <label><input type="radio" name="takeoff" value="fiveOrSix"> 擲 5 或 6</label>
                  <label><input type="radio" name="takeoff" value="even"> 擲偶數</label>
                </fieldset>
                <fieldset>
                  <legend>連擲 / 懲罰</legend>
                  <label><input type="checkbox" name="extraTurnOnSix" checked> 擲 6 可再擲</label>
                  <label><input type="checkbox" name="tripleSixPenalty"> 三連 6 懲罰</label>
                </fieldset>
                <fieldset>
                  <legend>吃子 / 堵路</legend>
                  <label><input type="checkbox" name="captureOnLand" checked> 落點吃子</label>
                  <label><input type="checkbox" name="stackEnabled" checked> 自家疊子</label>
                  <label><input type="checkbox" name="stackMovesTogether"> 疊子合體移動</label>
                  <label><input type="checkbox" name="blockadePassThrough"> 允許穿越堵路</label>
                </fieldset>
                <fieldset>
                  <legend>捷徑</legend>
                  <label><input type="checkbox" name="ownColorJumpEnabled" checked> 自色跳格</label>
                  <label>跳幾格 <input type="number" min="1" max="6" name="ownColorJumpSteps" value="4"></label>
                  <label><input type="checkbox" name="dashedFlightEnabled" checked> 虛線飛行</label>
                  <label><input type="checkbox" name="captureOnFlight" checked> 飛行落點吃子</label>
                </fieldset>
                <fieldset>
                  <legend>終點</legend>
                  <label><input type="checkbox" name="homeLaneExactEntry" checked> 入家路要精準</label>
                  <label>
                    完成規則
                    <select name="finishExact">
                      <option value="exact" selected>剛好到達</option>
                      <option value="noMoveIfOver">超出不得前進</option>
                      <option value="bounceBack">超出折返</option>
                    </select>
                  </label>
                </fieldset>
                <fieldset>
                  <legend>其他</legend>
                  <label><input type="checkbox" name="startTileSafe" checked> 起飛格安全</label>
                  <label>動畫速度
                    <select name="animSpeed">
                      <option value="slow">慢</option>
                      <option value="normal" selected>正常</option>
                      <option value="fast">快</option>
                    </select>
                  </label>
                  <label>回合計時（秒）<input type="number" name="turnTimerSec" min="0" value="0"></label>
                  <label><input type="checkbox" name="undoEnabled" checked> 允許 Undo</label>
                </fieldset>
              </div>
            </details>
          </fieldset>

          <div class="row" style="margin-top:12px">
            <button type="submit" class="btn" id="btn-start">開始遊戲</button>
            <button type="button" class="btn" id="btn-quick">快速開始（經典）</button>
            <button type="button" class="btn" id="btn-continue" disabled>繼續上局</button>
          </div>
        </form>
      </div>
    </section>

    <!-- 2) Game / Board View -->
    <section id="view-game" class="board-area" hidden aria-labelledby="title-game">
      <h2 id="title-game" class="sr-only">對局</h2>

      <div class="card board-wrap" role="application" aria-label="棋盤">
        <!-- SVG Board (generated by JS) -->
        <svg class="board" viewBox="0 0 1000 1000" role="img" aria-label="Aeroplane Chess Board">
          <desc>棋盤會用程式動態產生：外圈路徑、飛線、顏色區域與家路。</desc>
          <g id="layer-grid"></g>
          <g id="layer-tiles"></g>
          <g id="layer-specials"></g>
          <g id="layer-pieces"></g>
          <g id="layer-highlights"></g>
        </svg>
      </div>

      <aside class="card" aria-label="回合控制">
        <div class="row" style="justify-content:space-between">
          <strong id="turn-indicator">當前：—</strong>
          <span id="timer" class="muted" aria-live="polite"></span>
        </div>
        <div class="row" style="margin-top:8px">
          <button class="btn" id="btn-roll" aria-live="assertive" aria-label="擲骰">擲骰 🎲</button>
          <output id="dice-output" aria-live="polite" class="pill">–</output>
        </div>
        <div id="toast-host" aria-live="polite"></div>
        <div id="hint-card" aria-live="polite"></div>
        <div style="margin-top:12px">
          <h3 class="section-title" style="font-size:1rem">可移動棋子</h3>
          <div id="movables" class="list" aria-live="polite"></div>
        </div>
        <div style="margin-top:12px">
          <h3 class="section-title" style="font-size:1rem">戰報</h3>
          <div id="log" class="log" role="log" aria-live="polite"></div>
        </div>
        <div class="row" style="margin-top:12px">
          <button class="btn" id="btn-undo">Undo</button>
          <button class="btn" id="btn-restart">重開局</button>
        </div>
      </aside>
    </section>
  </main>

  <!-- 3) Dialogs -->
  <dialog id="dialog-settings" aria-labelledby="dialog-settings-title">
    <form method="dialog" class="card" style="min-width:320px">
      <h3 id="dialog-settings-title" class="section-title">設定</h3>
      <label>鍵盤控制
        <select id="keyboard-mode">
          <option value="shared" selected>共享模式：1–4 選棋、Space 擲骰</option>
          <option value="dual">雙人熱座：P1=1–4、P2=7–0</option>
        </select>
      </label>
      <label>主題
        <select id="theme">
          <option value="dark" selected>深色</option>
          <option value="light">淺色</option>
          <option value="high">高對比</option>
        </select>
      </label>
      <div class="row" style="margin-top:12px">
        <button class="btn" value="cancel">關閉</button>
      </div>
    </form>
  </dialog>

  <dialog id="dialog-about" aria-labelledby="dialog-about-title">
    <form method="dialog" class="card" style="min-width:320px">
      <h3 id="dialog-about-title" class="section-title">說明</h3>
      <p class="muted">在同一裝置上輪流操作的本地多人飛行棋。支援規則自訂與續盤。</p>
      <div class="row" style="margin-top:12px">
        <button class="btn" value="cancel">知道了</button>
      </div>
    </form>
  </dialog>

  <!-- 4) Templates (for cloning) -->
  <template id="tpl-player-card">
    <div class="card" data-player-card>
      <div class="row" style="justify-content:space-between;align-items:center">
        <strong>玩家 <span data-idx></span></strong>
        <span class="pill" data-color-pill>●</span>
      </div>
      <div class="row" style="margin-top:8px">
        <label>名稱 <input type="text" data-name placeholder="Mandy / Brian" /></label>
        <label>顏色
          <select data-color>
            <option value="red">紅</option>
            <option value="blue">藍</option>
            <option value="yellow">黃</option>
            <option value="green">綠</option>
          </select>
        </label>
        <label>類型
          <select data-type>
            <option value="human" selected>人類</option>
            <option value="ai">AI</option>
          </select>
        </label>
      </div>
    </div>
  </template>

  <!-- 5) App Script -->
  <script>
  // ========================= Rules Engine (Part 2) =========================
  (function(){
    const BOARD = {
      boardSpecVersion: "classic-52-v1",
      track: { length: 52, orderClockwise: ["red","blue","yellow","green"], startIndex: { red:0, blue:13, yellow:26, green:39 } },
      homeLane: { length: 6, entryIndex: { red:50, blue:11, yellow:24, green:37 } },
      special: {
        safeTiles: { start:true, extra:[] },
        ownColorJump: {
          enabled:true, steps:4,
          indices:{
            red:[2,6,10,14,18,22,26,30,34,38,42,46,50],
            blue:[15,19,23,27,31,35,39,43,47,51,3,7,11],
            yellow:[28,32,36,40,44,48,0,4,8,12,16,20,24],
            green:[41,45,49,1,5,9,13,17,21,25,29,33,37]
          }
        },
        flightPaths:{ enabled:true, captureOnLanding:true, edges:{
          red:[{from:4,to:17},{from:8,to:21}],
          blue:[{from:17,to:30},{from:21,to:34}],
          yellow:[{from:30,to:43},{from:34,to:47}],
          green:[{from:43,to:4},{from:47,to:8}],
        } }
      },
      bases:{ perPlayer:4 }
    };

    const DEFAULT_RULES = {
      takeoff:"six", extraTurnOnSix:true, tripleSixPenalty:false,
      captureOnLand:true, stackEnabled:true, stackMovesTogether:false, blockadePassThrough:false,
      ownColorJump:{enabled:true,steps:4}, dashedFlight:{enabled:true,captureOnLanding:true},
      homeLaneExactEntry:true, finishExact:"exact", safeTiles:{start:true,list:[]},
      turnTimerSec:0, animSpeed:'normal', undoEnabled:true,
    };

    const mod = (n,m)=>((n%m)+m)%m;
    const clone = (x)=> (window.structuredClone? structuredClone(x) : JSON.parse(JSON.stringify(x)));

    const Pos = {
      base:(slot=0)=>({kind:'base',slot}),
      track:(idx)=>({kind:'track',idx}),
      home:(idx)=>({kind:'home',idx}),
      finished:()=>({kind:'finished'}),
      isEqual:(a,b)=>{
        if(a.kind!==b.kind) return false;
        const key = (obj)=>{
          if(typeof obj.idx==='number') return obj.idx;
          if(typeof obj.slot==='number') return obj.slot;
          return -1;
        };
        return key(a)===key(b);
      }
    };

    function buildOccupancy(state){
      const occ={ track:Array(BOARD.track.length).fill(0).map(()=>({})), home:{} };
      for(const p of state.players){
        for(const pc of state.pieces[p.id]){
          const pos=pc.pos;
          if(pos.kind==='track') occ.track[pos.idx][p.color]=(occ.track[pos.idx][p.color]||0)+1;
          else if(pos.kind==='home'){
            if(!occ.home[p.color]) occ.home[p.color]=Array(BOARD.homeLane.length).fill(0);
            occ.home[p.color][pos.idx]+=1;
          }
        }
      }
      return occ;
    }

    function canTakeoffWith(dice,rules){
      if(rules.takeoff==='six') return dice===6;
      if(rules.takeoff==='fiveOrSix') return dice===5||dice===6;
      if(rules.takeoff==='even') return dice%2===0;
      return dice===6;
    }

    function isOwnJumpTile(color,idx){ return BOARD.special.ownColorJump.indices[color].includes(idx); }
    function flightTo(color,idx){ const e=BOARD.special.flightPaths.edges[color].find(e=>e.from===idx); return e?e.to:null; }
    function isStartTile(color,idx){ return idx===BOARD.track.startIndex[color]; }
    function isAnyStartTile(idx){ return Object.values(BOARD.track.startIndex).includes(idx); }
    function isSafeTrackTile(color,idx,rules){
      if(rules.safeTiles.start && isAnyStartTile(idx)) return true;
      return (rules.safeTiles.list||[]).includes(idx);
    }

    function generateLegalMoves(state,rules,dice){
      const player = state.players.find(p=>p.id===state.turn);
      if(!player) return [];
      const occ = buildOccupancy(state);
      const myPieces = state.pieces[player.id]||[];
      const moves=[];
      const stackInfo=new Map();
      if(rules.stackMovesTogether){
        const byIdx=new Map();
        myPieces.forEach((piece,idx)=>{
          if(piece.pos?.kind==='track'){
            if(!byIdx.has(piece.pos.idx)) byIdx.set(piece.pos.idx,[]);
            byIdx.get(piece.pos.idx).push(idx);
          }
        });
        byIdx.forEach((indices,idx)=>{
          indices.sort((a,b)=>a-b);
          stackInfo.set(idx,{indices,leader:indices[0]});
        });
      }
      myPieces.forEach((piece,i)=>{
        const pos=piece.pos; if(!pos || pos.kind==='finished') return;
        let stackGroup=null;
        if(rules.stackMovesTogether && pos.kind==='track'){
          const info=stackInfo.get(pos.idx);
          if(info && info.indices.length>1){
            if(i!==info.leader) return;
            stackGroup=info.indices.slice();
          }
        }
        if(pos.kind==='base'){
          if(canTakeoffWith(dice,rules)){
            const destIdx = BOARD.track.startIndex[player.color];
            const tileOcc = occ.track[destIdx];
            const enemyCount = Object.entries(tileOcc).filter(([c,n])=>c!==player.color).reduce((a,[,n])=>a+n,0);
            const allyCount = tileOcc[player.color]||0;
            if(!(allyCount>0 && !rules.stackEnabled) && !(enemyCount>=2 && !rules.blockadePassThrough)){
              const events=[]; let final=Pos.track(destIdx);
              const special=resolveSpecialsAfterLanding(player,final,rules,occ,events);
              final=special.final; const eventLog=special.events;
              const capture=resolveCaptureOnTrack(player,final,rules,occ,{viaFlight:special.viaFlight});
              if(!(capture?.blocked)) moves.push({pieceIndex:i,kind:'takeoff',dice,from:pos,to:final,events:eventLog,capture,stack:[i]});
            }
          }
          return;
        }
        const sim = simulateMove(player,pos,dice,rules,occ);
        if(sim && sim.legal){
          const group = stackGroup?stackGroup.slice():[i];
          moves.push({pieceIndex:i,kind:'move',dice,from:pos,to:sim.final,events:sim.events,capture:sim.capture,stack:group});
        }
      });
      return moves;
    }

    function simulateMove(player,fromPos,dice,rules,occ){
      let current=clone(fromPos); let remaining=dice; let events=[];
      const entryIdx=BOARD.homeLane.entryIndex[player.color];
      const isEnemyBlockade=(idx)=>{ const tileOcc=occ.track[idx]; return Object.entries(tileOcc).filter(([c,n])=>c!==player.color).some(([,n])=>n>=2); };
      let stepsTaken=0;
      while(remaining>0){
        if(current.kind==='track'){
          if(current.idx===entryIdx){
            if(stepsTaken===0 || !rules.homeLaneExactEntry){
              if(remaining<=0) break;
              current=Pos.home(0); remaining-=1; stepsTaken+=1; events.push({type:'enter-home'}); continue;
            }
          }
          const nextIdx = mod(current.idx+1, BOARD.track.length);
          if(!rules.blockadePassThrough && isEnemyBlockade(nextIdx)) return {legal:false,reason:'blocked-by-enemy-stack',events};
          current=Pos.track(nextIdx); remaining-=1; stepsTaken+=1;
          if(current.idx===entryIdx){
            const allowEntry = !rules.homeLaneExactEntry || remaining===0;
            if(allowEntry){
              current=Pos.home(0);
              events.push({type:'enter-home'});
            }
          }
        } else if(current.kind==='home'){
          const next=current.idx+1;
          if(next<BOARD.homeLane.length){ current=Pos.home(next); remaining-=1; stepsTaken+=1; }
          else {
            if(rules.finishExact==='exact') return {legal:false,reason:'need-exact-to-finish',events};
            if(rules.finishExact==='noMoveIfOver') return {legal:false,reason:'no-move-if-over',events};
            if(rules.finishExact==='bounceBack'){ const last=BOARD.homeLane.length-1; const over=next-last; const idx=last-(over-1); current=Pos.home(idx); remaining-=1; stepsTaken+=1; }
          }
        } else if(current.kind==='base' || current.kind==='finished'){
          return {legal:false,reason:'invalid-start',events};
        }
      }
      let capture=null;
      if(current.kind==='track'){
        const special=resolveSpecialsAfterLanding(player,current,rules,occ,events);
        current=special.final; events=special.events;
        capture=resolveCaptureOnTrack(player,current,rules,occ,{viaFlight:special.viaFlight});
        if(capture?.blocked) return {legal:false,reason:'land-on-enemy-blockade',events};
      } else if(current.kind==='home'){
        if(current.idx===BOARD.homeLane.length-1){ current=Pos.finished(); events.push({type:'finish'}); }
      }
      return {legal:true,final:current,events,capture};
    }

    function resolveSpecialsAfterLanding(player,pos,rules,occ,events){
      let current=clone(pos);
      let viaFlight=false;
      if(rules.ownColorJump.enabled && current.kind==='track' && isOwnJumpTile(player.color,current.idx)){
        const target = mod(current.idx + rules.ownColorJump.steps, BOARD.track.length);
        current = Pos.track(target); events.push({type:'jump',from:pos.idx,to:target});
      }
      const flightsEnabled = (BOARD.special.flightPaths?.enabled!==false);
      const flightRule = rules.dashedFlight||{};
      if(flightsEnabled && flightRule.enabled && current.kind==='track'){
        const to = flightTo(player.color,current.idx);
        if(to!=null){ current=Pos.track(to); events.push({type:'flight',from:pos.idx,to}); viaFlight=true; }
      }
      return {final:current,events,viaFlight};
    }

    function resolveCaptureOnTrack(player,pos,rules,occ,context={}){
      if(pos.kind!=='track' || !rules.captureOnLand) return null;
      const boardAllowsFlightCapture = BOARD.special.flightPaths.captureOnLanding!==false;
      const flightRule = rules.dashedFlight||{};
      if(context?.viaFlight && (!boardAllowsFlightCapture || flightRule.captureOnLanding===false)) return null;
      const tileOcc=occ.track[pos.idx];
      const enemyEntries=Object.entries(tileOcc).filter(([c,n])=>c!==player.color && n>0);
      if(enemyEntries.some(([,n])=>n>=2) && !rules.blockadePassThrough) return {blocked:true};
      if(isSafeTrackTile(player.color,pos.idx,rules)) return {captured:[]};
      const captured=[]; for(const [c,n] of enemyEntries){ for(let i=0;i<n;i++) captured.push({color:c}); }
      return {captured};
    }

    window.GameRules = { BOARD, DEFAULT_RULES, generateLegalMoves, simulateMove, buildOccupancy, Pos, canTakeoffWith };

    // ------------ Dev Console Smoke Tests -------------
    (function devTests(){
      const players=[{id:'P1',name:'Mandy',color:'red'},{id:'P2',name:'Brian',color:'blue'}];
      const mkBasePieces=()=>Array.from({length:BOARD.bases.perPlayer},(_,i)=>({pos:Pos.base(i)}));
      const basePieces={P1:mkBasePieces(),P2:mkBasePieces()};
      const state={turn:'P1',players,pieces:clone(basePieces)}; const rules=DEFAULT_RULES;
      console.log('[Test] 起飛(6) 應有步：', generateLegalMoves(state,rules,6));
      state.pieces.P1[0].pos = Pos.track(BOARD.track.startIndex.red);
      let occ = buildOccupancy(state); console.log('[Test] 從起點走2：', simulateMove(players[0], state.pieces.P1[0].pos, 2, rules, occ));
      // 新增：吃子測試
      state.pieces.P2[0].pos = Pos.track((BOARD.track.startIndex.red+2)%BOARD.track.length);
      occ = buildOccupancy(state); console.log('[Test] 可否吃子：', generateLegalMoves(state,rules,2));
      // 新增：入家路/完成測試（構造接近終點）
      state.turn='P1'; state.pieces.P1[0].pos = Pos.home(4); // homeLen=6, 走2應到終點
      occ = buildOccupancy(state); console.log('[Test] 終點精準：', simulateMove(players[0], state.pieces.P1[0].pos, 2, rules, occ));
    })();
  })();
  // ========================= End Rules Engine =========================
  </script>

  <script>
  // =============================== App ================================
  (function ensureUniqueIds(){
    const used=new Set();
    document.querySelectorAll('[id]').forEach(el=>{
      if(!el.id) return;
      if(!used.has(el.id)){
        used.add(el.id);
        return;
      }
      const base=el.id;
      let suffix=2;
      let candidate=`${base}-${suffix}`;
      while(used.has(candidate)){
        suffix+=1;
        candidate=`${base}-${suffix}`;
      }
      console.warn?.(`[ensureUniqueIds] duplicated id "${base}" renamed to "${candidate}"`);
      el.id=candidate;
      used.add(candidate);
    });
  })();
  const App = {
    state:{ view:'lobby', players:[], rules:null, pieces:{}, turn:null, dice:null, history:[], settings:{keyboardMode:'shared'}, animating:false, consecutiveSixes:{}, turnTimerId:null, turnTimerRemaining:0, controlById:{}, inputLockUntil:0 },
    geom:{ track:[], home:{}, bases:{} },
    init(){
      if(this._initialized) return;
      this._initialized=true;
      this.cache(); this.bind(); this.renderLobbyPlayers(2);
      this.bootstrapBoard();
      this.toGame();
      if(localStorage.getItem('ac_save_v1')) this.$.btnContinue.disabled=false;
      this.autoLaunch();
    },
    cache(){
      this.$={
        viewLobby:$('#view-lobby'), viewGame:$('#view-game'), playerCount:$('#playerCount'), playerList:$('#player-list'),
        formSetup:$('#form-setup'), btnQuick:$('#btn-quick'), btnStart:$('#btn-start'), btnLobby:$('#btn-lobby'), btnRoll:$('#btn-roll'),
        diceOut:$('#dice-output'), movables:$('#movables'), log:$('#log'), turn:$('#turn-indicator'), kbMode:$('#keyboard-mode'), timer:$('#timer'), hintCard:$('#hint-card'), turnBanner:$('#turn-banner'), toast:$('#toast-host'),
        btnUndo:$('#btn-undo'), btnRestart:$('#btn-restart'), btnContinue:$('#btn-continue'), svg:document.querySelector('svg.board'),
        gGrid:$('#layer-grid'), gTiles:$('#layer-tiles'), gSpecials:$('#layer-specials'), gPieces:$('#layer-pieces'), gHL:$('#layer-highlights')
      };
      function $(sel){ return document.querySelector(sel); }
    },
    bind(){
      if(this._bound) return;
      this._bound=true;
      this.$.playerCount.addEventListener('change',e=>this.renderLobbyPlayers(parseInt(e.target.value,10)));
      this.$.formSetup.addEventListener('submit',e=>{ e.preventDefault(); this.startGame(); });
      this.$.btnQuick.addEventListener('click',()=>{ this.applyPreset('classic'); this.startGame(); });
      this.$.btnContinue.addEventListener('click',()=>this.continueFromSave());
      this.$.btnLobby.addEventListener('click',()=>this.toLobby());
      this.$.btnRoll.addEventListener('click',()=>this.rollDice('mouse'));
      this.$.btnUndo.addEventListener('click',()=>this.undo());
      this.$.btnRestart.addEventListener('click',()=>this.restartGame());
      $('#btn-settings').addEventListener('click',()=>$('#dialog-settings').showModal());
      $('#btn-about').addEventListener('click',()=>$('#dialog-about').showModal());
      this.$.kbMode.addEventListener('change',e=>{ this.state.settings.keyboardMode=e.target.value; this.log(`鍵盤模式：${this.state.settings.keyboardMode}`); this.updateControlAssignments(); this.renderHints(); this.updateTurnPrompt(true); });
      document.addEventListener('keydown',e=>this.onKey(e));
    },
    lockInput(ms=0){
      if(this._inputUnlockTimer){ clearTimeout(this._inputUnlockTimer); this._inputUnlockTimer=null; }
      if(!(ms>0)){ this.state.inputLockUntil=0; return; }
      this.state.inputLockUntil=Date.now()+ms;
      this._inputUnlockTimer=setTimeout(()=>{ this.state.inputLockUntil=0; this._inputUnlockTimer=null; },ms);
    },
    isInputLocked(){ return Date.now()< (this.state.inputLockUntil||0); },
    showToast(message,duration=1600){
      const host=this.$?.toast; if(!host) return;
      if(!this._toast){ this._toast=document.createElement('div'); this._toast.className='toast-message'; host.appendChild(this._toast); }
      if(this._toastTimer){ clearTimeout(this._toastTimer); this._toastTimer=null; }
      if(!message){ this._toast.dataset.show='false'; this._toastTimer=setTimeout(()=>{ if(this._toast) this._toast.dataset.show='false'; },0); return; }
      this._toast.textContent=message;
      this._toast.dataset.show='true';
      this._toastTimer=setTimeout(()=>{ if(this._toast) this._toast.dataset.show='false'; },duration);
    },
    updateControlAssignments(){
      const mode=this.state.settings.keyboardMode||'shared';
      const map={};
      this.state.players.forEach((player,idx)=>{
        if(mode==='shared'){ map[player.id]='keyboard'; }
        else if(mode==='dual'){ map[player.id]=(idx<=1?'keyboard':'mouse'); }
        else { map[player.id]='mouse'; }
      });
      this.state.controlById=map;
    },
    currentPlayer(){ return this.state.players.find(p=>p.id===this.state.turn)||null; },
    currentControlModeForTurn(){
      const player=this.currentPlayer();
      if(!player) return 'mouse';
      const mode=this.state.controlById?.[player.id];
      return mode||'mouse';
    },
    isInteractionPermitted(source){
      if(source==='system') return true;
      if(this.isInputLocked()){ return false; }
      const control=this.currentControlModeForTurn();
      if(control==='keyboard' && source==='mouse') return false;
      if(control==='mouse' && source==='keyboard') return false;
      return true;
    },
    handleBlockedInteraction(source){
      const player=this.currentPlayer();
      if(this.isInputLocked()){ this.showToast('請稍候，提示顯示中…',900); return; }
      if(!player) return;
      const control=this.currentControlModeForTurn();
      if(control==='keyboard' && source==='mouse') this.showToast(`${player.name} 回合需用鍵盤操作`,1400);
      else if(control==='mouse' && source==='keyboard') this.showToast(`${player.name} 回合請用滑鼠`,1400);
    },
    renderHints(){
      const host=this.$?.hintCard; if(!host) return;
      const player=this.currentPlayer();
      host.innerHTML='';
      if(!player){
        host.innerHTML='<p class="hint-meta">等待遊戲開始…</p>';
        return;
      }
      const control=this.currentControlModeForTurn();
      const stage=(this.state.dice==null)?'roll':'move';
      const list=document.createElement('ul');
      const title=document.createElement('h3');
      title.textContent=`${player.name} 的操作提示`;
      const hints=[];
      const moveCount=Array.isArray(this.state.legalMoves)?this.state.legalMoves.length:0;
      const mode=this.state.settings.keyboardMode||'shared';
      const playerIndex=this.state.players.findIndex(p=>p.id===player.id);
      if(control==='keyboard'){
        if(stage==='roll') hints.push('按 Space 擲骰 🎲');
        if(mode==='shared'){ hints.push('用 1–4 選棋'); }
        else if(mode==='dual'){
          if(playerIndex===0) hints.push('P1：用 1–4 選棋');
          else if(playerIndex===1) hints.push('P2：用 7–0 選棋');
          else hints.push('此玩家以滑鼠操作');
        }
        if(stage==='move'){
          if(moveCount>0) hints.push('選擇數字鍵執行移動');
          else hints.push('沒有可移動棋子，等待換手');
        }
        if(this.state.rules?.undoEnabled) hints.push('按 U 撤銷 (Undo)');
      }else{
        if(stage==='roll') hints.push('點擊「擲骰 🎲」開始');
        if(stage==='move'){
          if(moveCount>0) hints.push('點擊棋子或右側按鈕移動');
          else hints.push('目前沒有可行動的棋子');
        }
        if(this.state.rules?.undoEnabled) hints.push('如需撤銷，可點 Undo 按鈕');
      }
      hints.forEach(text=>{ const li=document.createElement('li'); li.textContent=text; list.appendChild(li); });
      const meta=document.createElement('div');
      meta.className='hint-meta';
      meta.textContent=control==='keyboard'?'此回合鎖定鍵盤操作':'此回合鎖定滑鼠操作';
      host.appendChild(title);
      host.appendChild(list);
      host.appendChild(meta);
    },
    buildTurnPrompt(){
      const player=this.currentPlayer();
      if(!player) return '';
      const control=this.currentControlModeForTurn();
      const stage=(this.state.dice==null)?'roll':'move';
      let action='準備中';
      if(stage==='roll') action = control==='keyboard' ? '按 Space 擲骰 🎲' : '點擊 🎲 擲骰';
      else if(stage==='move') action = control==='keyboard' ? '用數字鍵選棋' : '點擊棋子行動';
      else action='等待下一步';
      return `${player.name} 的回合 — ${action}`;
    },
    showTurnPrompt(message,{duration=2200,force=false,lock=0}={}){
      const host=this.$?.turnBanner; if(!host) return;
      if(!message){ host.dataset.show='false'; host.setAttribute('hidden',''); this._currentPrompt=''; return; }
      if(!force && this._currentPrompt===message) return;
      this._currentPrompt=message;
      host.textContent=message;
      host.dataset.show='true';
      host.removeAttribute('hidden');
      if(this._turnBannerTimer){ clearTimeout(this._turnBannerTimer); }
      this._turnBannerTimer=setTimeout(()=>{
        host.dataset.show='false';
        this._turnBannerTimer=setTimeout(()=>{ host.setAttribute('hidden',''); },220);
      },duration);
      if(lock>0) this.lockInput(lock);
    },
    updateTurnPrompt(force=false){
      const msg=this.buildTurnPrompt();
      const stage=(this.state.dice==null)?'roll':'move';
      const lock=force && stage==='roll'?320:0;
      if(msg) this.showTurnPrompt(msg,{force,duration:2200,lock});
      else this.showTurnPrompt('',{force:true});
    },
    autoLaunch(){
      if(this._autoLaunched) return;
      this._autoLaunched=true;
      requestAnimationFrame(()=>{
        const saved=this.loadGame();
        if(saved){
          this._pendingToast='已載入上局，繼續作戰！';
          this.continueFromSave(saved);
        }else{
          this._pendingToast='已快速開始經典對局';
          this.startGame();
        }
      });
    },
    log(message){
      const host=this.$?.log; if(!host) return;
      const entry=document.createElement('div');
      const time=new Date().toLocaleTimeString('zh-HK',{hour12:false});
      entry.textContent=`[${time}] ${message}`;
      host.appendChild(entry);
      while(host.childElementCount>80){ host.removeChild(host.firstChild); }
      host.scrollTop=host.scrollHeight;
    },
    getAnimDuration(base){
      const speed=(this.state.rules?.animSpeed)||'normal';
      if(speed==='slow') return Math.round(base*1.35);
      if(speed==='fast') return Math.round(base*0.65);
      return base;
    },
    clearTurnTimer(){
      if(this.state.turnTimerId){ clearTimeout(this.state.turnTimerId); this.state.turnTimerId=null; }
      this.state.turnTimerRemaining=0;
      if(this.$?.timer) this.$.timer.textContent='';
    },
    beginTurnTimer(){
      const secs=Number(this.state.rules?.turnTimerSec||0);
      if(!(secs>0)){ this.clearTurnTimer(); return; }
      this.clearTurnTimer();
      this.state.turnTimerRemaining=secs;
      const tick=()=>{
        if(!this.$?.timer) return;
        this.$.timer.textContent=`⏱️ ${Math.max(0,this.state.turnTimerRemaining)}s`;
        if(this.state.turnTimerRemaining<=0){
          this.state.turnTimerId=null;
          this.handleTurnTimerExpired();
          return;
        }
        this.state.turnTimerRemaining-=1;
        this.state.turnTimerId=setTimeout(tick,1000);
      };
      tick();
    },
    handleTurnTimerExpired(){
      const player=this.currentPlayer();
      if(!player) return;
      this.log(`${player.name} 超時！`);
      if(this.state.dice==null){
        this.rollDice('system');
      }else{
        this.log('回合已自動結束');
        this.advanceTurn();
      }
    },
    refreshLegalMoves(){
      if(!this.state.rules){ this.state.legalMoves=[]; this.highlightMovables(); return; }
      if(this.state.dice==null){
        this.state.legalMoves=[];
      }else{
        const snapshot={players:this.state.players,pieces:this.state.pieces,turn:this.state.turn};
        this.state.legalMoves=window.GameRules.generateLegalMoves(snapshot,this.state.rules,this.state.dice);
      }
      this.highlightMovables();
    },
    handleNoMoves(player){
      this.clearTurnTimer();
      const name=player?.name||'該玩家';
      this.showTurnPrompt(`${name} 無步可走`,{duration:1600,force:true,lock:400});
      this.renderHints();
      if(this._noMoveTimer){ clearTimeout(this._noMoveTimer); }
      this._noMoveTimer=setTimeout(()=>{
        this._noMoveTimer=null;
        this.advanceTurn();
      },1200);
    },
    updateTurnUI(){
      const player=this.currentPlayer();
      this.$.turn.textContent=player?`當前：${player.name}`:'當前：—';
      this.$.btnRoll.disabled=this.state.animating||this.state.dice!=null;
      const canUndo=!!(this.state.rules?.undoEnabled && Array.isArray(this.state.history) && this.state.history.length>0);
      this.$.btnUndo.disabled=!canUndo;
      this.$.diceOut.textContent=this.state.dice==null?'–':String(this.state.dice);
      if(this.state.turnTimerId==null && this.state.dice==null){
        this.beginTurnTimer();
      }
      this.refreshLegalMoves();
      this.renderHints();
      this.updateTurnPrompt();
    },
    renderLobbyPlayers(n){
      const host=this.$.playerList; host.innerHTML='';
      const colors=['red','blue','yellow','green'];
      for(let i=0;i<n;i++){
        const tpl=document.getElementById('tpl-player-card'); const node=tpl.content.cloneNode(true);
        node.querySelector('[data-idx]').textContent=i+1;
        node.querySelector('[data-name]').value = i===0?'Mandy':(i===1?'Brian':'');
        node.querySelector('[data-color]').value = colors[i%colors.length];
        node.querySelector('[data-type]').value = (i<2?'human':'ai');
        host.appendChild(node);
      }
    },
    applyPreset(name){
      const cloneRules=(extra={})=>{
        const base=window.GameRules.DEFAULT_RULES;
        const copy = (window.structuredClone? structuredClone(base) : JSON.parse(JSON.stringify(base)));
        return Object.assign(copy,extra);
      };
      if(name==='classic') this.state.rules = cloneRules();
      else if(name==='fast') this.state.rules = cloneRules({takeoff:'fiveOrSix'});
      else this.state.rules = cloneRules();
    },
    readRulesFromForm(){
      const f=this.$.formSetup; const chk=n=>!!f.querySelector(`[name="${n}"]`)?.checked; const val=n=>f.querySelector(`[name="${n}"]:checked`)?.value; const num=(n,d)=>{const x=parseInt(f.querySelector(`[name="${n}"]`)?.value??d,10); return isNaN(x)?d:x;};
      return {
        takeoff: val('takeoff')||'six', extraTurnOnSix:chk('extraTurnOnSix'), tripleSixPenalty:chk('tripleSixPenalty'),
        captureOnLand:chk('captureOnLand'), stackEnabled:chk('stackEnabled'), stackMovesTogether:chk('stackMovesTogether'), blockadePassThrough:chk('blockadePassThrough'),
        ownColorJump:{enabled:chk('ownColorJumpEnabled'),steps:num('ownColorJumpSteps',4)}, dashedFlight:{enabled:chk('dashedFlightEnabled'),captureOnLanding:chk('captureOnFlight')},
        homeLaneExactEntry:chk('homeLaneExactEntry'), finishExact:(f.querySelector('[name="finishExact"]')?.value)||'exact',
        safeTiles:{start:chk('startTileSafe'),list:[]},
        turnTimerSec:Math.max(0,num('turnTimerSec',0)),
        animSpeed:(()=>{ const raw=(f.querySelector('[name="animSpeed"]')?.value)||'normal'; return ['slow','normal','fast'].includes(raw)?raw:'normal'; })(),
        undoEnabled:chk('undoEnabled')
      };
    },
    normalizePieces(){
      for(const player of this.state.players){
        const pcs=Array.isArray(this.state.pieces[player.id])?this.state.pieces[player.id]:[];
        pcs.forEach((pc,idx)=>{
          if(typeof pc.baseSlot!=='number') pc.baseSlot=idx;
          if(pc.pos?.kind==='base' && typeof pc.pos.slot!=='number') pc.pos.slot=pc.baseSlot;
        });
        this.state.pieces[player.id]=pcs;
      }
    },
    startGame(){
      // players
      const cards=this.$.playerList.querySelectorAll('[data-player-card]'); const players=[]; const seen=new Set();
      cards.forEach((card,idx)=>{ const name=card.querySelector('[data-name]').value||`玩家${idx+1}`; const color=card.querySelector('[data-color]').value; const type=card.querySelector('[data-type]').value||'human'; if(seen.has(color)) return; seen.add(color); players.push({id:`P${idx+1}`,name,color,type}); });
      if(players.length<2){ this.log('至少需要 2 位玩家'); return; }
      this.state.players=players; this.state.turn=players[0].id; this.state.history=[]; this.state.pieces={};
      this.state.consecutiveSixes={};
      this.updateControlAssignments();
      const preset=(this.$.formSetup.querySelector('input[name="preset"]:checked')?.value)||'classic';
      if(preset==='custom'){ this.state.rules = Object.assign({}, window.GameRules.DEFAULT_RULES, this.readRulesFromForm()); }
      else { this.applyPreset(preset); }
      const pieceCount=window.GameRules.BOARD.bases.perPlayer||1;
      for(const p of players){
        this.state.pieces[p.id]=Array.from({length:pieceCount},(_,idx)=>({pos:window.GameRules.Pos.base(idx), baseSlot:idx}));
        this.state.consecutiveSixes[p.id]=0;
      }
      this.normalizePieces();
      this.state.legalMoves=[]; this.state.animating=false; this.state.dice=null;
      this.$.diceOut.textContent='–';
      this.$.movables.innerHTML='';
      this.$.gHL.innerHTML='';
      this.$.log.innerHTML='';
      this.clearTurnTimer();
      this.toGame(); this.bootstrapBoard(); this.redrawPieces(); this.updateTurnUI(); this.updateTurnPrompt(true); this.saveGame(); this.log('遊戲開始！');
      const toastMsg=this._pendingToast||'新局開始，祝你順風！';
      if(toastMsg) this.showToast(toastMsg);
      this._pendingToast=null;
      this.maybeAutoPlayIfAI();
      this.$.btnContinue.disabled=false;
    },
    toGame(){ this.$.viewLobby.hidden=true; this.$.viewGame.hidden=false; this.state.view='game'; },
    toLobby(){ this.$.viewLobby.hidden=false; this.$.viewGame.hidden=true; this.state.view='lobby'; this.clearTurnTimer(); },

    restartGame(){
      if(!Array.isArray(this.state.players) || this.state.players.length<2){
        this.log('未有進行中的對局');
        return;
      }
      this.updateControlAssignments();
      const pieceCount=window.GameRules.BOARD.bases.perPlayer||1;
      this.state.pieces={};
      this.state.consecutiveSixes={};
      for(const p of this.state.players){
        this.state.pieces[p.id]=Array.from({length:pieceCount},(_,idx)=>({pos:window.GameRules.Pos.base(idx), baseSlot:idx}));
        this.state.consecutiveSixes[p.id]=0;
      }
      this.normalizePieces();
      this.state.turn=this.state.players[0].id;
      this.state.history=[];
      this.state.legalMoves=[];
      this.state.animating=false;
      this.state.dice=null;
      this.$.diceOut.textContent='–';
      this.$.movables.innerHTML='';
      this.$.gHL.innerHTML='';
      this.$.log.innerHTML='';
      this.clearTurnTimer();
      this.toGame();
      this.bootstrapBoard();
      this.redrawPieces();
      this.updateTurnUI();
      this.updateTurnPrompt(true);
      this.saveGame();
      this.log('已重開新局');
      const toastMsg=this._pendingToast||'新局已重置';
      if(toastMsg) this.showToast(toastMsg);
      this._pendingToast=null;
      this.maybeAutoPlayIfAI();
      this.$.btnContinue.disabled=false;
    },

    rollDice(source='system'){
      if(this.state.view!=='game'){ return; }
      if(!this.isInteractionPermitted(source)){ this.handleBlockedInteraction(source); return; }
      if(this.state.animating){ this.log('動畫進行中，稍候再擲'); return; }
      if(this.state.dice!=null){ this.log('本回合已擲骰'); return; }
      const player=this.currentPlayer();
      if(!player){ return; }
      const value=1+Math.floor(Math.random()*6);
      this.state.dice=value;
      this.$.diceOut.textContent=String(value);
      this.log(`${player.name} 擲出 ${value}`);
      const pid=player.id;
      const prev=this.state.consecutiveSixes?.[pid]||0;
      if(!this.state.consecutiveSixes) this.state.consecutiveSixes={};
      if(value===6){ this.state.consecutiveSixes[pid]=prev+1; }
      else { this.state.consecutiveSixes[pid]=0; }
      if(value===6 && this.state.rules?.tripleSixPenalty && this.state.consecutiveSixes[pid]>=3){
        this.log(`${player.name} 連續三次擲出 6，被判失去回合`);
        this.state.consecutiveSixes[pid]=0;
        this.state.dice=null;
        this.$.diceOut.textContent='–';
        this.state.legalMoves=[];
        this.highlightMovables();
        this.renderHints();
        this.clearTurnTimer();
        this.updateTurnPrompt(true);
        this.advanceTurn();
        return;
      }
      this.refreshLegalMoves();
      this.renderHints();
      this.saveGame();
      const moveCount=(this.state.legalMoves||[]).length;
      if(moveCount===0){
        this.log(`${player.name} 無步可走`);
        this.handleNoMoves(player);
        return;
      }
      this.clearTurnTimer();
      this.beginTurnTimer();
      this.updateTurnPrompt(true);
      this.maybeAutoPlayIfAI();
    },

    // --------- Board Rendering ---------
    bootstrapBoard(){
      const svg=this.$.svg; const W=1000,H=1000; svg.setAttribute('viewBox',`0 0 ${W} ${H}`); const cx=W/2,cy=H/2,r=380;
      const gGrid=this.$.gGrid,gTiles=this.$.gTiles,gSpecials=this.$.gSpecials,gPieces=this.$.gPieces,gHL=this.$.gHL; gGrid.innerHTML=gTiles.innerHTML=gSpecials.innerHTML=gPieces.innerHTML=gHL.innerHTML='';
      const NS='http://www.w3.org/2000/svg'; const css=getComputedStyle(document.documentElement); const color=(name)=>css.getPropertyValue(name).trim();
      const geom=this.geom={track:[],home:{},bases:{}};
      const el=(n,a={},ch=[])=>{ const node=document.createElementNS(NS,n); for(const [k,v] of Object.entries(a)) node.setAttribute(k,v); ch.forEach(c=>node.appendChild(c)); return node; };
      const parseHex=(hex)=>{ const h=hex.replace('#',''); const parts=h.length===3?h.split('').map(c=>parseInt(c+c,16)):h.match(/.{2}/g).map(v=>parseInt(v,16)); return{r:parts[0],g:parts[1],b:parts[2]}; };
      const mixWithWhite=(hex,amount)=>{ const {r,g,b}=parseHex(hex); const mix=c=>Math.round(c+(255-c)*amount); return`rgb(${mix(r)},${mix(g)},${mix(b)})`; };
      const withAlpha=(hex,alpha)=>{ const {r,g,b}=parseHex(hex); return`rgba(${r},${g},${b},${alpha})`; };
      const ringPoint=(i,total=window.GameRules.BOARD.track.length)=>{ const a=(Math.PI*2)*(i/total)-Math.PI/2; const radius=r-20; return{ x:cx+Math.cos(a)*radius, y:cy+Math.sin(a)*radius, angle:a }; };
      gGrid.appendChild(el('circle',{cx,cy,r:r+60,fill:'#0a0a0a',stroke:color('--tile-grid'),'stroke-width':2,opacity:.5}));
      const total=window.GameRules.BOARD.track.length; const startIdx=window.GameRules.BOARD.track.startIndex; const entryIdx=window.GameRules.BOARD.homeLane.entryIndex; const ownJump=window.GameRules.BOARD.special.ownColorJump.indices;
      const defs=el('defs'); svg.insertBefore(defs, svg.firstChild);
      const jumpPatterns={};
      const ensureJumpPattern=(col)=>{
        if(jumpPatterns[col]) return jumpPatterns[col];
        const hex=color(`--${col}`); const pattern=el('pattern',{id:`jump-${col}`,patternUnits:'userSpaceOnUse',width:10,height:10});
        pattern.appendChild(el('rect',{width:10,height:10,fill:withAlpha(hex,0.12)}));
        pattern.appendChild(el('circle',{cx:3,cy:3,r:1.4,fill:withAlpha(hex,0.35)}));
        pattern.appendChild(el('circle',{cx:8,cy:8,r:1.2,fill:withAlpha(hex,0.28)}));
        defs.appendChild(pattern); jumpPatterns[col]=pattern; return pattern;
      };
      const ownJumpLookup={}; Object.entries(ownJump).forEach(([col,arr])=>arr.forEach(idx=>{ ownJumpLookup[idx]=col; }));
      const tileSize=44;
      for(let i=0;i<total;i++){
        const {x,y,angle}=ringPoint(i); geom.track[i]={x,y,angle};
        const attrs={x:x-tileSize/2,y:y-tileSize/2,width:tileSize,height:tileSize,rx:10,fill:'transparent',stroke:color('--tile-grid'),'stroke-width':2};
        const jumpCol=ownJumpLookup[i];
        if(jumpCol){ const hex=color(`--${jumpCol}`); attrs.fill=mixWithWhite(hex,0.15); attrs['fill-opacity']=0.9; attrs.stroke=withAlpha(hex,0.6); attrs['stroke-width']=2.5; }
        gTiles.appendChild(el('rect',attrs));
        if(jumpCol){ ensureJumpPattern(jumpCol); gTiles.appendChild(el('rect',{x:x-tileSize/2,y:y-tileSize/2,width:tileSize,height:tileSize,rx:10,fill:`url(#jump-${jumpCol})`,opacity:0.5})); }
      }
      const startIndexByColor=Object.fromEntries(Object.entries(startIdx).map(([col,idx])=>[idx,col]));
      const entryIndexByColor=Object.fromEntries(Object.entries(entryIdx).map(([col,idx])=>[idx,col]));
      for(let i=0;i<total;i++){
        const {x,y}=geom.track[i];
        if(entryIndexByColor[i]!=null){
          const col=entryIndexByColor[i];
          const entry={x,y};
          const dir={x:cx-entry.x,y:cy-entry.y};
          const len=Math.hypot(dir.x,dir.y)||1; const ux=dir.x/len,uy=dir.y/len;
          const outward={x:-ux,y:-uy};
          const tip={x:entry.x+ux*(tileSize*0.28), y:entry.y+uy*(tileSize*0.28)};
          const baseCenter={x:entry.x+outward.x*(tileSize*0.32), y:entry.y+outward.y*(tileSize*0.32)};
          const perp={x:-uy,y:ux}; const baseHalf=tileSize*0.22;
          const p1={x:baseCenter.x+perp.x*baseHalf,y:baseCenter.y+perp.y*baseHalf};
          const p2={x:baseCenter.x-perp.x*baseHalf,y:baseCenter.y-perp.y*baseHalf};
          gSpecials.appendChild(el('polygon',{points:`${tip.x},${tip.y} ${p1.x},${p1.y} ${p2.x},${p2.y}`,fill:withAlpha(color(`--${col}`),0.85)}));
        }
        if(startIndexByColor[i]!=null){
          const col=startIndexByColor[i];
          const dotRadius=tileSize*0.18; const ringRadius=tileSize*0.32;
          const hex=color(`--${col}`);
          gSpecials.appendChild(el('circle',{cx:x,cy:y,r:ringRadius,stroke:withAlpha(hex,0.5),'stroke-width':3,fill:'transparent'}));
          gSpecials.appendChild(el('circle',{cx:x,cy:y,r:dotRadius,fill:hex}));
        }
      }
      const flights=window.GameRules.BOARD.special.flightPaths.edges; const flightGroup=el('g',{});
      const bezierTangent=(t,p0,p1,p2)=>{ const mt=1-t; return{ x:2*mt*(p1.x-p0.x)+2*t*(p2.x-p1.x), y:2*mt*(p1.y-p0.y)+2*t*(p2.y-p1.y) }; };
      for(const [ck,edges] of Object.entries(flights)){
        const strokeColor=color(`--${ck}`);
        for(const e of edges){
          const p0=geom.track[e.from]; const p2=geom.track[e.to];
          const mid={x:(p0.x+p2.x)/2,y:(p0.y+p2.y)/2};
          const vec={x:p2.x-p0.x,y:p2.y-p0.y}; const segLen=Math.hypot(vec.x,vec.y)||1; const unit={x:vec.x/segLen,y:vec.y/segLen};
          let normal={x:-unit.y,y:unit.x};
          const midFromCenter={x:mid.x-cx,y:mid.y-cy};
          if(normal.x*midFromCenter.x+normal.y*midFromCenter.y<0){ normal={x:-normal.x,y:-normal.y}; }
          const k=0.32; const control={x:mid.x+normal.x*(segLen*k), y:mid.y+normal.y*(segLen*k)};
          const path=el('path',{d:`M ${p0.x} ${p0.y} Q ${control.x} ${control.y} ${p2.x} ${p2.y}`,stroke:strokeColor,'stroke-width':4,fill:'none',opacity:.78,'stroke-linecap':'round'});
          flightGroup.appendChild(path);
          const tTip=0.985; const arrowTip={x:p2.x,y:p2.y};
          const tan=bezierTangent(tTip,p0,control,p2); const tanLen=Math.hypot(tan.x,tan.y)||1; const tanUnit={x:tan.x/tanLen,y:tan.y/tanLen};
          const arrowLen=12; const baseCenter={x:arrowTip.x-tanUnit.x*arrowLen,y:arrowTip.y-tanUnit.y*arrowLen};
          const normalVec={x:-tanUnit.y,y:tanUnit.x}; const arrowWidth=12;
          const c1={x:baseCenter.x+normalVec.x*(arrowWidth/2),y:baseCenter.y+normalVec.y*(arrowWidth/2)};
          const c2={x:baseCenter.x-normalVec.x*(arrowWidth/2),y:baseCenter.y-normalVec.y*(arrowWidth/2)};
          const arrow=el('polygon',{points:`${arrowTip.x},${arrowTip.y} ${c1.x},${c1.y} ${c2.x},${c2.y}`,fill:strokeColor,opacity:.9});
          flightGroup.appendChild(arrow);
        }
      }
      gSpecials.appendChild(flightGroup);
      const homeLen=window.GameRules.BOARD.homeLane.length; Object.entries(entryIdx).forEach(([col,idx])=>{
        const entry=geom.track[idx]; const dir={x:cx-entry.x,y:cy-entry.y}; const len=Math.hypot(dir.x,dir.y)||1; const ux=dir.x/len,uy=dir.y/len;
        const spacing=tileSize+10; const offset=tileSize*0.6;
        geom.home[col]=[];
        for(let i=0;i<homeLen;i++){
          const dist=offset+i*spacing;
          const x=entry.x+ux*dist; const y=entry.y+uy*dist;
          geom.home[col][i]={x,y};
          const fill=i===homeLen-1?`var(--${col})`:'transparent';
          const stroke=i===homeLen-1?`var(--${col})`:color('--tile-grid');
          gTiles.appendChild(el('rect',{x:x-tileSize/2,y:y-tileSize/2,width:tileSize,height:tileSize,rx:10,fill,stroke,'stroke-width':2}));
        }
      });
      gGrid.appendChild(el('rect',{x:cx-60,y:cy-60,width:120,height:120,transform:`rotate(45 ${cx} ${cy})`,fill:'#0f172a',stroke:color('--tile-grid'),'stroke-width':2}));
      const baseDefs={red:{dx:-350,dy:-350},blue:{dx:350,dy:-350},yellow:{dx:350,dy:350},green:{dx:-350,dy:350}};
      for(const [col,{dx,dy}] of Object.entries(baseDefs)){ const group=el('g',{}); const x=cx+dx,y=cy+dy,w=180,h=180; group.appendChild(el('rect',{x:x-w/2,y:y-h/2,width:w,height:h,rx:22,fill:`var(--${col})`,opacity:.14,stroke:`var(--${col})`,'stroke-width':2})); const slots=[]; for(let i=-1;i<=1;i+=2){ for(let j=-1;j<=1;j+=2){ const sx=x+i*40,sy=y+j*40; slots.push({x:sx,y:sy}); group.appendChild(el('circle',{cx:sx,cy:sy,r:22,fill:'none',stroke:`var(--${col})`,'stroke-width':2,opacity:.8})); } } geom.bases[col]=slots; gGrid.appendChild(group); }
      gGrid.appendChild(el('circle',{cx,cy,r:r+150,fill:'none',stroke:'#000','stroke-width':140,opacity:.35}));
    }
,
    highlightMovables(){
      const g=this.$.gHL; g.innerHTML='';
      const host=this.$.movables; host.innerHTML='';
      const player=this.currentPlayer(); if(!player) return;

      const moves=this.state.legalMoves||[];
      const byPiece=new Map();
      moves.forEach(m=>{
        if(!byPiece.has(m.pieceIndex)) byPiece.set(m.pieceIndex,[]);
        byPiece.get(m.pieceIndex).push(m);
      });

      const pcs=this.state.pieces[player.id]||[];
      pcs.forEach((pc,idx)=>{
        const where=this.posToXY(player.color,pc.pos,idx);
        if(!where) return;
        const hasMove=byPiece.has(idx);
        const ring=document.createElementNS('http://www.w3.org/2000/svg','circle');
        ring.setAttribute('cx',where.x);
        ring.setAttribute('cy',where.y);
        ring.setAttribute('r',hasMove?28:22);
        ring.setAttribute('fill',hasMove?'rgba(34,211,238,0.12)':'rgba(255,255,255,0.03)');
        ring.setAttribute('stroke',hasMove?'var(--accent)':'transparent');
        ring.setAttribute('stroke-width',hasMove?'2':'0');
        if(hasMove){
          ring.style.cursor='pointer';
          ring.addEventListener('click',()=>{
            const options=byPiece.get(idx)||[];
            if(options.length===1){
              this.applyMove(options[0],'mouse');
            }else if(options.length>1){
              const firstBtn=host.querySelector(`button[data-piece="${idx}"]`);
              if(firstBtn){
                firstBtn.focus();
                if(firstBtn.scrollIntoView){
                  firstBtn.scrollIntoView({block:'nearest'});
                }
              }
            }
          });
        }
        g.appendChild(ring);

        const txt=document.createElementNS('http://www.w3.org/2000/svg','text');
        txt.setAttribute('x',where.x);
        txt.setAttribute('y',where.y+4);
        txt.setAttribute('text-anchor','middle');
        txt.setAttribute('font-size','14');
        txt.setAttribute('fill','#e5e7eb');
        txt.textContent=String(idx+1);
        g.appendChild(txt);

        if(hasMove){
          const movesForPiece=byPiece.get(idx);
          movesForPiece.forEach((mv,optIdx)=>{
            const btn=document.createElement('button');
            btn.type='button';
            btn.className='btn';
            btn.dataset.piece=String(idx);
            btn.dataset.option=String(optIdx);
            const prefix=movesForPiece.length>1?`${idx+1} 號棋（選項 ${optIdx+1}）`:`${idx+1} 號棋`;
            btn.textContent=`${prefix}：${this.describeMove(mv)}`;
            btn.addEventListener('click',()=>this.applyMove(mv,'mouse'));
            host.appendChild(btn);
          });
        }
      });

      if(host.childElementCount===0){
        const span=document.createElement('span');
        span.className='muted';
        span.textContent='沒有可移動棋子';
        host.appendChild(span);
      }
    },
    describeMove(move){
      const parts=[];
      if(move.kind==='takeoff') parts.push('起飛');
      else if(typeof move.dice==='number') parts.push(`前進 ${move.dice}`);
      if(Array.isArray(move.stack) && move.stack.length>1) parts.push(`疊子×${move.stack.length}`);
      if(move.events){
        if(move.events.some(ev=>ev.type==='enter-home')) parts.push('入家路');
        if(move.events.some(ev=>ev.type==='jump')) parts.push('跳格');
        if(move.events.some(ev=>ev.type==='flight')) parts.push('飛行');
        if(move.events.some(ev=>ev.type==='finish')) parts.push('終點');
      }
      const capturedCount=Array.isArray(move.capture?.captured)?move.capture.captured.length:0;
      if(capturedCount>0) parts.push('吃子');
      return parts.join(' → ')||'移動';
    },
    posToXY(color,pos,pieceIndex=null){
      if(pos.kind==='track') return this.geom.track[pos.idx];
      if(pos.kind==='home') return this.geom.home[color][pos.idx];
      if(pos.kind==='base'){
        const slots=this.geom.bases[color]||[];
        if(slots.length===0) return null;
        const slotFromPos=(typeof pos.slot==='number')?pos.slot:null;
        const idx=(slotFromPos!=null?slotFromPos:(pieceIndex!=null?pieceIndex:0));
        return slots[idx%slots.length];
      }
      return null;
    },
    redrawPieces(){
      const g=this.$.gPieces; g.innerHTML='';
      g.onclick=(e)=>{
        if(this.state.animating) return;
        if(!this.isInteractionPermitted('mouse')){ this.handleBlockedInteraction('mouse'); return; }
        const target=e.target.closest('[data-player][data-index]');
        if(!target) return;
        const pid=target.dataset.player;
        const idx=parseInt(target.dataset.index,10);
        if(pid!==this.state.turn||Number.isNaN(idx)) return;
        const mv=(this.state.legalMoves||[]).find(m=>m.pieceIndex===idx);
        if(mv) this.applyMove(mv,'mouse');
      };
      for(const p of this.state.players){
        const pcs=this.state.pieces[p.id]||[];
        pcs.forEach((pc,idx)=>{
          const xy=this.posToXY(p.color,pc.pos,idx);
          if(!xy) return;
          const c=document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('cx',xy.x);
          c.setAttribute('cy',xy.y);
          c.setAttribute('r',18);
          c.setAttribute('fill',`var(--${p.color})`);
          c.setAttribute('stroke','#0b0f14');
          c.setAttribute('stroke-width','3');
          c.dataset.player=p.id;
          c.dataset.index=idx;
          this.$.gPieces.appendChild(c);
          const t=document.createElementNS('http://www.w3.org/2000/svg','text');
          t.setAttribute('x',xy.x);
          t.setAttribute('y',xy.y+4);
          t.setAttribute('text-anchor','middle');
          t.setAttribute('font-size','12');
          t.setAttribute('fill','#0b0f14');
          t.textContent=String(idx+1);
          t.dataset.player=p.id;
          t.dataset.index=idx;
          t.style.cursor='pointer';
          this.$.gPieces.appendChild(t);
        });
      }
    },

    applyMove(move,source='system'){
      if(!move) return;
      if(!this.isInteractionPermitted(source)){ this.handleBlockedInteraction(source); return; }
      this.pushHistory();
      const pid=this.state.turn;
      const player=this.currentPlayer();
      let movingIndices=Array.isArray(move.stack)?move.stack.slice():[move.pieceIndex];
      if(!movingIndices.includes(move.pieceIndex)) movingIndices.push(move.pieceIndex);
      movingIndices=Array.from(new Set(movingIndices)).sort((a,b)=>a-b);
      const movingPieces=movingIndices.map(idx=>({idx,piece:this.state.pieces[pid]?.[idx]})).filter(entry=>entry.piece);
      const leadEntry=movingPieces.find(entry=>entry.idx===move.pieceIndex) || movingPieces[0];
      if(!leadEntry){ this.state.animating=false; return; }
      const piece=leadEntry.piece;
      const fromXY=this.posToXY(player.color,piece.pos,leadEntry.idx);
      const toXY=this.posToXY(player.color,move.to,leadEntry.idx)||fromXY;
      this.state.animating=true;
      this.animatePiece(player,fromXY,toXY,this.getAnimDuration(520)).then(async()=>{
        const capturedInfos=[];
        if(move.capture && move.capture.captured && move.capture.captured.length>0 && move.to.kind==='track'){
          for(const opp of this.state.players){
            if(opp.id===pid) continue;
            const oppPieces=this.state.pieces[opp.id]||[];
            oppPieces.forEach((pc,idx)=>{
              if(pc.pos.kind==='track' && pc.pos.idx===move.to.idx){
                capturedInfos.push({opp,pieceIndex:idx});
              }
            });
          }
        }

        for(const info of capturedInfos){
          const from=this.geom.track[move.to.idx];
          const capturedPiece=this.state.pieces[info.opp.id]?.[info.pieceIndex];
          const slotIndex=typeof capturedPiece?.baseSlot==='number'?capturedPiece.baseSlot:info.pieceIndex;
          const targetBase=this.posToXY(info.opp.color, window.GameRules.Pos.base(slotIndex), slotIndex);
          if(targetBase){
            await this.animatePiece({color:info.opp.color}, from, targetBase, this.getAnimDuration(420));
          }
        }

        const toPosition=(target,slot)=>{
          if(!target) return null;
          if(target.kind==='track') return window.GameRules.Pos.track(target.idx);
          if(target.kind==='home') return window.GameRules.Pos.home(target.idx);
          if(target.kind==='finished') return window.GameRules.Pos.finished();
          if(target.kind==='base') return window.GameRules.Pos.base(slot);
          try{ return window.structuredClone? window.structuredClone(target):JSON.parse(JSON.stringify(target)); }catch(e){ return target; }
        };

        movingPieces.forEach(({idx,piece:pc})=>{
          const slotIndex=typeof pc.baseSlot==='number'?pc.baseSlot:idx;
          pc.baseSlot=slotIndex;
          if(move.to.kind==='base'){
            pc.pos=window.GameRules.Pos.base(slotIndex);
          }else{
            pc.pos=toPosition(move.to,slotIndex);
          }
        });

        if(capturedInfos.length>0){
          for(const info of capturedInfos){
            const capturedPiece=this.state.pieces[info.opp.id]?.[info.pieceIndex];
            if(!capturedPiece) continue;
            const slot=typeof capturedPiece.baseSlot==='number'?capturedPiece.baseSlot:info.pieceIndex;
            capturedPiece.baseSlot=slot;
            capturedPiece.pos=window.GameRules.Pos.base(slot);
          }
          this.log(`${player.name} 吃子！把對手送回基地`);
        }

        if(movingPieces.length>1){
          this.log(`${player.name} 疊子合體移動（${movingPieces.length} 枚）`);
        }

        if(move.events){
          move.events.forEach(ev=>{
            if(ev.type==='enter-home') this.log(`${player.name} 進入家路`);
            if(ev.type==='jump') this.log(`${player.name} 觸發跳格 (+${this.state.rules?.ownColorJump?.steps||0})`);
            if(ev.type==='flight') this.log(`${player.name} 走飛線`);
            if(ev.type==='finish') this.log(`${player.name} 抵達終點！`);
          });
        }

        this.redrawPieces();
        this.$.gHL.innerHTML='';
        this.pulseAt(toXY.x,toXY.y,`var(--${player.color})`);
        if(move.to.kind==='track'){
          const faces=this.computeThreatFaces(move.to.idx);
          this.showThreatBadge(toXY.x,toXY.y,faces);
        }else{
        this.showThreatBadge(toXY.x,toXY.y,[]);
      }

      const again=(this.state.dice===6 && this.state.rules?.extraTurnOnSix);
      this.state.animating=false;
      this.renderHints();
      if(!again){
        this.advanceTurn();
      }else{
        this.state.dice=null;
        this.$.diceOut.textContent='–';
        this.state.legalMoves=[];
        this.clearTurnTimer();
        this.beginTurnTimer();
        this.saveGame();
        this.updateTurnUI();
        this.updateTurnPrompt(true);
        this.maybeAutoPlayIfAI();
      }
    });
  },
    advanceTurn(){
      if(!Array.isArray(this.state.players) || this.state.players.length===0) return;
      if(this._noMoveTimer){ clearTimeout(this._noMoveTimer); this._noMoveTimer=null; }
      const currentIdx=this.state.players.findIndex(p=>p.id===this.state.turn);
      const next=(currentIdx<0?0:(currentIdx+1)%this.state.players.length);
      const prevId=this.state.turn;
      const nextId=this.state.players[next].id;
      if(prevId!=null && this.state.consecutiveSixes){ this.state.consecutiveSixes[prevId]=0; }
      this.state.turn=nextId;
      if(this.state.consecutiveSixes){ this.state.consecutiveSixes[nextId]=0; }
      this.state.dice=null;
      this.state.legalMoves=[];
      this.$.diceOut.textContent='–';
      this.clearTurnTimer();
      this.updateTurnUI();
      this.saveGame();
      this.updateTurnPrompt(true);
      this.maybeAutoPlayIfAI();
    },
    onKey(e){
      if(this.state.view!=='game' || this.state.animating) return;
      if(e.key==='u'||e.key==='U'){ this.undo(); return; }
      if(!this.isInteractionPermitted('keyboard')){ this.handleBlockedInteraction('keyboard'); return; }
      const mode=this.state.settings.keyboardMode;
      const pIdx=this.state.players.findIndex(p=>p.id===this.state.turn);
      const pieces=this.state.pieces[this.state.turn]||[];
      const pieceCount=pieces.length;
      if(e.code==='Space'){
        e.preventDefault();
        this.rollDice('keyboard');
        return;
      }
      let selIndex=null;
      if(mode==='shared'){
        const keys=['1','2','3','4','5','6','7','8','9'];
        const idx=keys.indexOf(e.key);
        if(idx>-1 && idx<pieceCount) selIndex=idx;
      } else if(mode==='dual'&&this.state.players.length>=2){
        if(pIdx===0){
          const keys=['1','2','3','4'];
          const idx=keys.indexOf(e.key);
          if(idx>-1 && idx<pieceCount) selIndex=idx;
        } else if(pIdx===1){
          const keys=['7','8','9','0'];
          const idx=keys.indexOf(e.key);
          if(idx>-1 && idx<pieceCount) selIndex=idx;
        }
      }
      if(selIndex!=null){
        const mv=(this.state.legalMoves||[]).find(m=>m.pieceIndex===selIndex);
        if(mv) this.applyMove(mv,'keyboard');
      }
    },

    // --------- Persistence / Undo ---------
    snapshot(){ return JSON.parse(JSON.stringify({players:this.state.players,pieces:this.state.pieces,turn:this.state.turn,rules:this.state.rules,dice:this.state.dice,consecutiveSixes:this.state.consecutiveSixes})); },
    saveGame(){ try{ localStorage.setItem('ac_save_v1', JSON.stringify(this.snapshot())); }catch(e){} },
    loadGame(){ try{ const s=localStorage.getItem('ac_save_v1'); return s?JSON.parse(s):null; }catch(e){ return null; } },
    clearSave(){ try{ localStorage.removeItem('ac_save_v1'); }catch(e){} },
    continueFromSave(data=null){
      const snapshot=data||this.loadGame();
      if(!snapshot){ this.log('冇儲存對局'); return; }
      this.state.players=snapshot.players||[];
      this.state.pieces=snapshot.pieces||{};
      this.state.turn=snapshot.turn||null;
      const loadedRules=snapshot.rules? Object.assign({}, window.GameRules.DEFAULT_RULES, snapshot.rules) : window.GameRules.DEFAULT_RULES;
      this.state.rules=loadedRules;
      this.state.dice=snapshot.dice??null;
      this.state.consecutiveSixes=snapshot.consecutiveSixes||{};
      this.state.history=[];
      this.normalizePieces();
      this.updateControlAssignments();
      this.toGame();
      this.bootstrapBoard();
      this.redrawPieces();
      this.clearTurnTimer();
      this.beginTurnTimer();
      this.updateTurnUI();
      this.updateTurnPrompt(true);
      this.log('已載入上局');
      const toastMsg=this._pendingToast||'已載入上局';
      if(toastMsg) this.showToast(toastMsg);
      this._pendingToast=null;
      if(this.$?.btnContinue) this.$.btnContinue.disabled=false;
      this.maybeAutoPlayIfAI();
    },
    pushHistory(){
      if(!this.state.rules?.undoEnabled) return;
      const snap=this.snapshot();
      if(!Array.isArray(this.state.history)) this.state.history=[];
      this.state.history.push(snap);
      if(this.state.history.length>20) this.state.history.shift();
    },
    undo(){
      if(!this.state.rules?.undoEnabled){ this.log('未啟用 Undo'); return; }
      const snap=this.state.history?.pop?.();
      if(!snap){ this.log('無可 Undo 嘅步'); return; }
      this.state.players=snap.players; this.state.pieces=snap.pieces; this.state.turn=snap.turn; this.state.rules=snap.rules;
      this.state.dice=snap.dice??null; this.state.consecutiveSixes=snap.consecutiveSixes||{};
      this.normalizePieces();
      this.$.diceOut.textContent=this.state.dice==null?'–':String(this.state.dice);
      this.clearTurnTimer();
      this.beginTurnTimer();
      this.redrawPieces(); this.$.gHL.innerHTML='';
      this.updateTurnUI();
      this.saveGame();
      this.log('已撤銷一步');
      this.maybeAutoPlayIfAI();
    },

    // --------- AI ---------
    isAI(player){ return (player.type||'human')==='ai'; },
    chooseAIMove(){
      const player=this.currentPlayer();
      const moves=this.state.legalMoves||[];
      if(moves.length===0) return null;
      const rules=this.state.rules||window.GameRules.DEFAULT_RULES;
      const distToFinish=(color,pos)=>{
        const L=window.GameRules.BOARD.track.length;
        const entry=window.GameRules.BOARD.homeLane.entryIndex[color];
        const homeLen=window.GameRules.BOARD.homeLane.length;
        if(pos.kind==='finished') return 0;
        if(pos.kind==='home') return (homeLen-1-pos.idx);
        if(pos.kind==='track'){
          const dToEntry=((entry-pos.idx)%L+L)%L;
          return dToEntry+1+(homeLen-1);
        }
        return 999;
      };
      const isSafeTile=(color,idx)=>{
        const start=window.GameRules.BOARD.track.startIndex[color];
        if(rules.safeTiles?.start && idx===start) return true;
        return (rules.safeTiles?.list||[]).includes(idx);
      };
      const captureRiskProb=(color,idx)=>{
        if(isSafeTile(color,idx)) return 0;
        let hits=0;
        const L=window.GameRules.BOARD.track.length;
        for(const opp of this.state.players){
          if(opp.id===player.id) continue;
          const oppPieces=this.state.pieces[opp.id]||[];
          for(const pc of oppPieces){
            if(pc.pos.kind!=='track') continue;
            const d=((idx-pc.pos.idx)%L+L)%L;
            if(d>=1&&d<=6) hits+=1;
          }
        }
        return Math.min(1,hits/6);
      };
      const myPieces=this.state.pieces[player.id]||[];
      const scored=moves.map(m=>{
        const beforePos=myPieces[m.pieceIndex]?.pos||window.GameRules.Pos.base();
        const before=distToFinish(player.color,beforePos);
        const after=distToFinish(player.color,m.to);
        let score=(before-after)*4;
        const cap=(m.capture&&(m.capture.captured||[]).length)||0;
        score+=cap*1000;
        if(m.to.kind==='finished') score+=900;
        if((m.events||[]).some(e=>e.type==='enter-home')) score+=400;
        if((m.events||[]).some(e=>e.type==='jump')) score+=140;
        if((m.events||[]).some(e=>e.type==='flight')) score+=90;
        if(m.kind==='takeoff') score+=80;
        if(m.to.kind==='track' && isSafeTile(player.color,m.to.idx)) score+=60;
        if(m.to.kind==='track'){
          const prob=captureRiskProb(player.color,m.to.idx);
          score-=prob*700;
        }
        return {move:m,score,before,after};
      });
      scored.sort((a,b)=> b.score!==a.score? b.score-a.score : ((a.before-a.after)!==(b.before-b.after)? (b.before-b.after)-(a.before-a.after) : (((b.move.capture?.captured||[]).length)-((a.move.capture?.captured||[]).length))));
      return scored[0].move;
    },
    maybeAutoPlayIfAI(){
      if(this.state.view!=='game') return;
      const player=this.currentPlayer();
      if(!this.isAI(player)) return;
      setTimeout(()=>{
        if(this.state.animating) return this.maybeAutoPlayIfAI();
        const current=this.currentPlayer();
        if(!this.isAI(current)) return;
        if(current.id!==player.id){
          this.maybeAutoPlayIfAI();
          return;
        }
        if(this.state.dice==null){
          this.rollDice('system');
          return;
        }
        const mv=this.chooseAIMove();
        if(mv){
          this.applyMove(mv,'system');
        }else{
          this.log(`${current.name} 無步可走`);
          this.handleNoMoves(current);
        }
      },300);
    },

    // --------- Anim / Effects ---------
    animatePiece(player,from,to,duration=480){ duration=this.getAnimDuration(duration); return new Promise(resolve=>{ const g=this.$.gHL; const NS='http://www.w3.org/2000/svg'; const ghost=document.createElementNS(NS,'circle'); ghost.setAttribute('cx',from.x); ghost.setAttribute('cy',from.y); ghost.setAttribute('r',18); ghost.setAttribute('fill',`var(--${player.color})`); ghost.setAttribute('stroke','#0b0f14'); ghost.setAttribute('stroke-width','3'); g.appendChild(ghost); const t0=performance.now(); const ease=t=>1-Math.pow(1-t,3); const step=(now)=>{ const p=Math.min(1,(now-t0)/duration), e=ease(p); const x=from.x+(to.x-from.x)*e, y=from.y+(to.y-from.y)*e; ghost.setAttribute('cx',x); ghost.setAttribute('cy',y); if(p<1) requestAnimationFrame(step); else { g.removeChild(ghost); resolve(); } }; requestAnimationFrame(step); }); },
    pulseAt(x,y,color){ const g=this.$.gHL; const NS='http://www.w3.org/2000/svg'; const ring=document.createElementNS(NS,'circle'); ring.setAttribute('cx',x); ring.setAttribute('cy',y); ring.setAttribute('r','8'); ring.setAttribute('fill','none'); ring.setAttribute('stroke',color); ring.setAttribute('stroke-width','3'); ring.setAttribute('opacity','0.9'); g.appendChild(ring); let r=8; const id=setInterval(()=>{ r+=4; ring.setAttribute('r',r); const op=parseFloat(ring.getAttribute('opacity')); ring.setAttribute('opacity',String(Math.max(0,op-0.12))); if(r>36){ clearInterval(id); g.removeChild(ring);} },16); },
    computeThreatFaces(targetIdx){ const L=window.GameRules.BOARD.track.length; const me=this.currentPlayer(); const faces=new Set(); for(const opp of this.state.players){ if(opp.id===me.id) continue; const oppPieces=this.state.pieces[opp.id]||[]; for(const pc of oppPieces){ if(pc.pos.kind!=='track') continue; const d=((targetIdx-pc.pos.idx)%L+L)%L; if(d>=1&&d<=6) faces.add(d); } } return Array.from(faces).sort((a,b)=>a-b); },
    showThreatBadge(x,y,faces){ const g=this.$.gHL; g.querySelectorAll('.threat-badge').forEach(n=>n.remove()); if(!faces||faces.length===0) return; const NS='http://www.w3.org/2000/svg'; const bx=x+26,by=y-26; const badge=document.createElementNS(NS,'g'); badge.setAttribute('class','threat-badge'); const rect=document.createElementNS(NS,'rect'); const label=faces.join('/'); const padding=6; const width=Math.max(24,label.length*7+padding*2); rect.setAttribute('x',bx-width/2); rect.setAttribute('y',by-10); rect.setAttribute('width',width); rect.setAttribute('height',20); rect.setAttribute('rx',6); rect.setAttribute('fill','#ef4444'); rect.setAttribute('stroke','#000'); rect.setAttribute('stroke-width','2'); const txt=document.createElementNS(NS,'text'); txt.setAttribute('x',bx); txt.setAttribute('y',by+5); txt.setAttribute('text-anchor','middle'); txt.setAttribute('font-size','12'); txt.setAttribute('fill','#0b0f14'); txt.textContent=label; badge.appendChild(rect); badge.appendChild(txt); g.appendChild(badge); }
  };
  window.App = App; window.addEventListener('DOMContentLoaded',()=>App.init());
  // ============================= End App ===============================
  </script>
</body>
</html>
